\lecture{8}{Сумма Минковского. Scan line.}
\subsection{Сумма Минковского.}
\begin{definition}
  \highlight{Суммой Минковского} двух множеств $S_1 \subset R^2, S_2 \subset R^2$ называется множество
  $S_1 \oplus S_2 \colon \{p + q \colon p \in S_1, q \in S_2\}$.
\end{definition}

\begin{definition}
  \highlight{Отрицанием} множества $S \subset R^2$ называется множество 
  
  $-S \colon \{-p \colon p \in S\}$.
\end{definition}

\begin{theorem}
  Сумма Минковского двух выпуклых многоугольников есть выпуклый многоугольник, количество вершин
  которого не превосходит сумму вершин двух исходных многоугольников.
\end{theorem}
\begin{proof}
  Любая крайняя точка в направлении какого-то вектора (это значит что мы проектируем нашу фигуру на вектор и
  выбираем самую крайнюю точку) складывается из крайних точек каждой фигуры в направлении этого же вектора.
  Так что каждое ребро из суммы Минковского мы можем сопоставить одному ребру исходной фигуры. Как же 
  это сделать? Выберем произвольное ребро $\alpha$ из суммы Минковского. Построим к нему нормаль и заметим, что
  это ребро, очевидно, крайнее относительно этой нормали, а значит, оно образовано двумя крайними точками
  исходных множеств. Это означает, что хотя бы у одной из фигур должно быть ребро, которое
  является крайним в направлении этой нормали. Сопопставим это ребро рассматриваемому ребру из суммы
  Минковского.
\end{proof}

Описание алгоритма:
\begin{enumerate}
  \item Сортируем грани каждого множества по полярному углу
  \item Начинаем обход с крайней левой точки в одну сторону, например
  \item Сливаем два массива сортированных массива рёбер
\end{enumerate}

\begin{remark}
  Время работы алгоритма $O(n + m)$, где $n$ и $m$ --- число граней в исходных множествах.
\end{remark}

Использование суммы Минковского:
\begin{itemize}
  \item Поиск диаметра множества
    \begin{enumerate}
      \item Ищем выпуклую оболочку $S$
      \item Считаем сумму Минковского $S \oplus -S$
      \item Находим самую дальнюю точку от нуля в получившейся сумме
    \end{enumerate}
    \begin{figure}[ht]
        \centering
        \incfig{mink}
        \caption*{Поиск диаметра}
        \label{fig:mink}
    \end{figure}
  \item Проверка пересечения выпуклых многоугольников
    \begin{enumerate}
      \item Находим $S = P \oplus -Q$
      \item Многоугольники будут пересекаться, если $(0, 0) \in S$
    \end{enumerate}
\end{itemize}

\subsection{Проверка принадлежности точки многоугольнику.}
Если мы пустим из точки луч, то чётность числа пересечений этого луча покажет, лежит точка внутри
многоугольника или нет. Если число пересечений нечётно, точка лежит внутри многоугольника.

Осталось обработать некоторые случаи, пусть мы проверяем принадлежность точки $q$, тогда итоговый алгоритм:
\begin{enumerate}
  \item Проходим по каждому ребру $ab$ многоугольника
  \item Если $q \in ab$, то сразу возвращаем $true$
  \item Если $a_{y} = b_{y}$, то пропускаем этот отрезок, он не влияет на чётность пересечений
  \item Если $q_{y} = max(a_{y}, b_{y})$ и $q_{x} < min(a_{x}, b_{x})$, то увеличиваем счётчик пересечений
  \item Если $q_{y} = min(a_{y}, b_{y})$, пропускаем это ребро
  \item Если $q_{y}$ лежит между $a_{y}$ и $b_{y}$ и поворот точек $a, b, q$ левый, то увеличиваем счётчик
    пересечений
\end{enumerate}
По сути, с помощью этого алгоритма мы учитываем только верхнюю точку какого-то ребра (чтобы избежать
повторного подсчёта какого-то ребра).

\subsection{Сканирующая прямая.}
Описание алгоритма:
Будем двигать вертикальную сканирующую прямую слева направо с $-\infty$ до $+\infty$.
Для каждого отрезка в какой-то момент времени его точка появится на прямой, затем с движением может
сдвинуться, а потом и вовсе пропасть. Для пересекающихся отрезков заметим, что их точки на сканирующей
прямой в какой-то момент совпадут. Будем рассматривать отрезки, отсортированные по $y$.

Тогда справедливы следующие утверждения:
\begin{itemize}
  \item Для поиска пересекающейся пары достаточно рассматривать при каждом положении сканирующей прямой
    только соседние отрезки, ведь два непересекающихся отрезка никогда не меняют своего относительного
    положения и два пересекающихся отрезка в момент точки своего пересечения окажутся соседями друг друга
    в списке.
  \item Достаточно рассматривать сканирующую прямую только в позициях, когда появлются или удаляются отрезки,
    ведь относительный порядок отрезка при вставке в наш список не меняется (вспомним про то, что
    непересекающиеся отрезки не меняют своего относительного порядка).
  \item При появлении нового отрезка достаточно вставить его на нужное место в списке и проверить его на
    пересечение с соседними отрезками с списке (это также следует из того, что, если отрезки пересекаются, то
    они будут соседями в списке).
  \item При исчезновении отрезка нужно также проверить на пересечение только сосдение отрезки (из
    предыдущего утверждения).
  \item Чтобы не пропустить пересечение отрезков по вершине (и корректно обработать вертикальные отрезки),
    необходимо сначала производить все вставки в список при появлении отрезка, а потом уже удаления.
\end{itemize}

\begin{remark}
  Асимптотика алгоритма $O(n \log n)$. Всего за алгоритм будет $O(n)$ операций со списком (для которого мы
  используем \texttt{std::set}), тем самым в итоге получаем $O(n \log n)$.
\end{remark}







