\lecture{6}{Вычислительная геометрия. Выпуклая оболочка 2D.}
\subsection{Геометрические понятия.}
Тут ничего нового, думаю, все и так всё знают. Обратим внимание читателя на две идеи:
\begin{itemize}
  \item Сравнивать вещественные числа нужно с использованием константы <<эпсилон>>
  \item Проверку знака угла поворота необходимо осуществлять без всяких тригонометрических функций для
    уменьшения погрешности. Можно воспользоваться векторным произведением.
\end{itemize}
\subsection{Выпуклая оболочка 2D.}
\begin{definition}
  \highlight{Выпуклое множество} --- множество $M$, в котором выполняется следующее свойство: 
  \[
  \forall P, Q \in M \colon PQ \in M
  .\] 
\end{definition}
\begin{definition}
  \highlight{Выпуклая оболочка множества} --- пересечение всех выпуклых множеств, содержащих все заданные
  точки.
\end{definition}

\begin{remark}
  В каждой граничной точке выпуклого множества существует касательная.
\end{remark}

\begin{definition}
  \highlight{Изохрона} --- множество точек, достижимых из данной за фиксированное время.
\end{definition}

\subsection{Алгоритм Джарвиса.}
Или же <<заворачивание подарка>> --- ищем выпуклую оболочку последовательно, против часовой стрелки,
начиная с определённой точки.

Приведём описание алгоритма:
\begin{enumerate}
  \item Возьмём самую нижнюю левую точку $p_0$ нашего множества.
  \item На каждом следующем шаге для последней добавленной точки $p_{i}$ ищем $p_{i+1}$ среди всех
    недобавленных точек и $p_0$ с максимальным полярным углом (при равенстве сравниваем по расстоянию),
    добавляем её. Если добавили $p_0$, заканчиваем алгоритм.
\end{enumerate}

\begin{remark}
  Корректность следует из построения, т.к. на каждом шаге алгоритма мы получаем прямую, относительно
  которой все точки множества лежат слева.
\end{remark}

\begin{remark}
  Асимптотика алгоритм $O(n \cdot h)$, где $h$ --- размер выпуклой оболочки. Таким образом, в худшем 
  случае $O(n^2)$.
\end{remark}

\subsection{Алгоритм Грэхема.}
Ищем точки последовательно, используя стек.

Приведём описание алгоритма:
\begin{enumerate}
  \item Возьмём самую нижнюю левую точку $p_0$ нашего множества.
  \item Сортирует остальные точки можества по полярному углу.
  \item Добавляем в ответ (в стек) $p_1$ --- самую первую из отсортированных точек.
  \item Берём следующую точку по счёту. Пока новая точка образует неправый поворот с предыдущими двумя,
    удаляем последнюю точку из стека.
  \item Добавляем эту следующую точку в ответ (в стек) и повторяем с пункта 3, пока не дойдём до начальной.
\end{enumerate}

Рассмотрим доказательство корректности алгоритма:
\begin{proof}
  Докажем по индукции. База из трёх точек очевидна.

  Пусть для $i - 1$ точек истинная оболочка совпадает с построенной. Теперь рассмотрим истинную
  оболочку $ch(S \cup i) = ch(S) \cup i \setminus P$, где $P$ --- множество всех точек, видимых из
  $i$ (это означает, что мы можем провести из $i$ отрезок до точки так, чтобы он не пересекал уже
  построенную оболочку). Мы строим оболочку против часовой стрелки, а $i$-ая точка точно лежит в 
  оболочке (мы так предположили в начале доказательства перехода), значит $P$ состоит из последних
  подряд идущих точках, которые мы добавили на предыдущих шагах, а именно их мы удаляем на текущем шаге.
  Переход доказан.
\end{proof}

\begin{remark}
  Асимптотика алгоритма $O(n\log n)$. Обход за $O(n)$ (каждая точка добавляется в ответ не более одного
  раза). Сортировка занимает $O(n \log n)$.
\end{remark}

\subsection{Разделяй и властвуй.}
\begin{enumerate}
  \item Делим изначальное множество на примерно равные множества. 
  \item Строим для каждого множества оболочку рекурсивно (или можем запустит Грехема). 
  \item Дальше сливаем полученные оболочки.
\end{enumerate}
\begin{remark}
  Если мы умеем сливать оболочки за $O(n)$, то асимптотика алгоритма $O(n \log n)$ по мастер-теореме из
   \[
     T(n) \leq C \cdot n + 2T \left( \frac{n}{2} \right) 
  .\] 
\end{remark}

Приведём пример алгоритма для слияния двух оболочек за $O(n)$.
\begin{enumerate}
  \item Берём у одной оболочки точку центра масс за опорную.
  \item Если центр масс оказался внутри второй оболочки, задача сводится к слиянию двух сортированных
    списков
  \item Иначе проводим касательные к второй оболочке, выкидываем точки, которые попали между касательных,
    сливаем оставшиеся точки.
\end{enumerate}

