\lecture{7}{Выпуклая оболочка 3D.}
\subsection{Заворачивание подарка.}
Некоторые предварительные сведения, которые будут относиться ко всем способам построения оболочки:
\begin{enumerate}
  \item Никакие три точки не лежат на одной прямой.
  \item Никакие четыре точки не лежат в одной плоскости.
  \item Точек как минимум 4.
\end{enumerate}

Также по теореме Эйлера имеем:
\[
  V - E + F = 2
,\] где $V$--- число вершин, $E$--- рёбер, $F$--- граней.

К тому же $3F \leq 2E \implies E + 6 \leq 3V$. Получили, что в выпуклой оболочке число граней и
рёбер равно $O(V)$. Это в дальшейшем пригодится в доказательствах.

Теперь опишем непосредственно алгоритм (пусть на вход подаются координаты точек $(x, y, z)$:
\begin{enumerate}
  \item Выбираем начальную точку $P$ с минимальной координатой $z$ (если таких несколько, можно взять любую) и
    добавляем в оболочку.
  \item Выбираем следующую точку $Q$ так, чтобы угол $PQ$ с плоскостью $Oxy$ был минимальным, берём её 
    в оболочку. Ребро $PQ$ принадлежит оболочкe.
  \item Выбираем следующую точку $R$ так, чтобы угол между $PQR$ и $Oxy$ был минимальным, берём её
    в оболочку. Грань $PQR$ принадлежит оболочке. Произошло заворачивание подарка.
  \item Каждое ребро полученной грани добавляем в очередь на обработку. Для каждого ребра из этой
    очережи нужно найти смежную грань выпуклой оболочки (аналогично ищем третью вершину грани так,
    чтобы угол между гранью, в которой изначально находится это ребро, и гранью, образованной
    ребром и новой точкой, был минимальный). Новая грань может добавить два ребра и закрывает
    хотя бы одно.
  \item Таким образом закрываем все рёбра из очереди гранями оболочки. Завершаем, когда закрыто
    последнее ребро.
\end{enumerate}

\begin{remark}
  Данный алгоритм работает за $O(n^2)$. Каждый шаг, включая первый, отрабатывает за $O(n)$, всего шагов
  $O(n)$ (размер оболочки). 
\end{remark}

\subsection{Видимые грани}

Описание алгоритма:
\begin{enumerate}
  \item Собираем тетраэдр из любых четырёх точек исходного множества.
  \item Для каждой нерассмотренной точки перебираем все построенные грани выпуклой оболочки. 
    Оставляем невидимые из точки грани. Удаляем видимые грани. (про видимость поговорим потом)
  \item Добавляем в оболочку новые грани, которые содержат рассматриваемую точку и рёбра на пересечении
    видимой и невидимой части граней.
\end{enumerate}

Для проверки видимости точки каждой грани храним в фиксированном порядке обхода относительно нормали
к грани. Тогда видимость означает сонаправленность нормали к грани и вектора от рассматриваемой точки к
грани (т.е. скалярное произведенеие больше $0$). Чтобы лучше понять эту часть, можно представить себе виток
с током, тогда направление тока задаёт обход точек грани, а вектор магнитной индукции --- нормаль к плоскости.

\begin{remark}
  Асимптотика алгоритма $O(n^2)$. Каждый шаг за $O(n)$, всего шагов $O(n)$.
\end{remark}

\subsection{Разделяй и властвуй}

Описание алгоритма:
\begin{enumerate}
  \item Разделяем точки плоскостью на примерно равное число точек.
  \item Рекурсивно строим каждую половинку. Если количество точек меньше $7$, строим за $O(n^2)$.
  \item Объединяем выпуклые оболочки в одну.
\end{enumerate}

Процесс объединение за $O(n)$.
\begin{enumerate}
  \item Проецируем на плоскость оболочки, находим между ними мост. Для этого можно идти по трём
    вершинам одной оболочки и смотреть на поведение, например, псевдо-векторного произведения этих
    трёх точек и нижней точки второй оболочки.
  \item Сливаем две оболочки от моста, найденного на
    предыдущем шаге, не учитывая вершины, выкинутые на предыдущем шаге.
\end{enumerate}

\begin{remark}
  Сложность алгоритма $O(n \log n)$. Но объединение не гарантированно за $O(n)$ 
  (из лекции есть сложные случаи).
\end{remark}

