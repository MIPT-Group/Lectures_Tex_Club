\lecture{3}{Суффиксный массив.}
\subsection{Суффиксный массив. Построение за $O(n^2 \log n)$.}
Пусть нам дана строка $s$ длины $n$.
\begin{definition}
        \highlight{i-ый суффикс строки} --- подстрока $s[i\ldots n-1]$.
\end{definition}
\begin{definition}
        \highlight{Суффиксный массив} --- перестановка индексов суффиксов в лексиграфическом порядке, 
        т.е. сортированный массив собственных суффиксов строки.
\end{definition}

Попробуем наивно построить наш массив. Для начала заметим, что сортировка суффиксов эквивалентна
сортировке циклических сдвигов строки с добавленным символом \highlight{сентиленом}, символом, который заведомо
не встречается в строке. Действительно, любой суффикс можно получить из строки циклическим сдвигом при
условии, что мы знаем, где конец у строчки (символ сентилен).

Тогда сравнение строк происходит за $O(n)$, используя сортировку за $O(n\log n)$, получаем итоговую
асимптотику $O(n^2 \log n)$.

\subsection{Поиск подстроки в тексте с использованием суффиксного массива.}

С помощью суффиксного массива можно искать все вхождения строки в другую. Для начала рассмотрим
наивное решение.

\begin{enumerate}
        \item Строим суффиксный массив.
        \item Наши суффиксны отсортированы, так что бинарным поискам по массиву можно найти диапазон,
        в котором исследуемая строка имеет тот же первый символ, что и суффиксы в диапазоне.
        Отбрасывая первый символ, мы не теряем отсортированность, так что мы можем аналогично
        применить бинарный поиск.
\end{enumerate}

\begin{remark}
        Асимптотика такого алгоритма $O(n \log m)$, где  $n$ --- длина образца, а $m$ --- длина текста.
\end{remark}
Для доказательства заметим, что сравнение суффикса с образцом не превышает длину образца.

Теперь рассмотрим более быстрый алгоритм. Во время бинарного поиска паттерн и все суффиксы из
рассматриваемого диапазона имеют общий префикс. Тогда идея в том, чтобы не сравнивать все символы из
префикса каждый раз. 

Для начала введём новое понятие:
\begin{definition}
        \highlight{LCP(x,y)} --- длина наибольшего общего префикса строк $x$ и $y$. 
\end{definition}

Общая идея алгоритма в том, что мы ищем границы ответа с помощью бинарного поиска по суффиксному
массиву. Опишем поиск левой границы ответа, правая ищется аналогично.

\begin{enumerate}
        \item Если образец больше последнего суффикса и меньше первого, то поиск можно останавливать, т.к.
        образец не встречается в строке.
        \item Введём некоторые обозначения: 
                \begin{itemize}
                        \item $L$ --- левая граница поиска в суффиксном массиве (т.е. индекс элемента,
                                левее которого мы не ищем).
                        \item $R$ --- правая граница поиска.
                        \item $M = \frac{L+R}{2}$. 
                        \item $p$ --- наш паттерн.
                        \item $suffix[]$ --- суффиксный массив.
                        \item $l = LCP(suffix[L], p)$ --- наименьший общий префикс элемента с левой границы
                        поиска и нашего паттерна.
                        \item $r = LCP(suffix[R], p)$.
                        \item $m_{l} = LCP(suffix[L], suffix[M])$.
                        \item  $m_{r} = LCP(suffix[R], suffix[M])$.
                \end{itemize}
        \item Положим изначально $L = 0$, $R = \left| S \right| $, где $S$ --- изначальная строка.
        \item На каждом шаге будем сравнивать $l$ и $r$ (изначально их можно найти с помощью алгоритма Касаи
        (о нём пойдёт речь далее).

        Тогда, если $l \geq r$:
        \begin{itemize}
                \item $m_{l} > l$. Тогда мы получили, что элементы из $[L, M]$ имеют общий префикс больше, 
                чем общий префикс левого суффикса и паттерна. Тогда мы должны пойти в отрезок $[M, R]$,
                ведь тогда на всём отрезке $[L, M]$ будет общий префикс такой, что он имеет различные
                символы с префиксом $p$ той же длины.
                \item $m_{l} = l$. Тогда нам остаётся проверить следующие символы $suffix[M]$ и $p$ и найти
                первый различный: если первый различный у  $p$ больше, чем у $suffix[M]$, то идём в отрезок
                $[M, R]$, иначе --- в $[L, M]$.
                \item $m_{l} < l$. Аналогично первому случаю идём в $[L, M]$.
        \end{itemize}

        Если $l < r$ всё аналогично. Запишем в сжатой форме:
        \begin{itemize}
                \item $m_{r} > r \implies R = M$.
                \item $m_{r} = r \implies$ считаем $LCP(suffix[M], p)$, действуем в зависимости от различного
                символа.
                \item $m_{r} < r \implies L = M$.
        \end{itemize}
\end{enumerate}

Тогда асимптотика полученного алгоритма $O(p + log(S))$, если мы предпосчитали $LCP$ (делаем не более $O(p)$
сравнений символов и  $O(log(S))$ занимает бинарный поиск по массиву суффиксов). Иначе $O(p \log S)$ в
худшем случае.

\subsection{Построение суффиксного массива за $O(n \log n)$.}

Для начала отметим, что сортировать мы будем не суффиксы, а циклические сдвиги строки с сентиленом
(что эквивалентно). Соответственно введём понятие \highlight{циклической подстроки}
$s[i\ldots j] \text{ при } j < i \colon s[i\ldots n-1] + s[0\ldots j]$.

Наш алгоритм состоит из $\lceil \log n \rceil$. На $i$-ой фазе будут сортироваться циклические подстроки
длины $2^{i}$. На каждой фазе мы поддерживаем массив перестановки циклических подстрок $p$ и 
массив \highlight{классов эквивалентности} для подстрок.

\begin{definition}
        \highlight{Массив классов эквивалентности} --- массив, который удовлетворяет следующим свойствам:
        \begin{itemize}
                \item Если один суффикс меньше другого, то и номер класса он получает меньший.
                \item Если суффиксы равны, то и их классы эквивалентности равны.
                \item Номер класса $c[i]$ соответствует подстроке, начинающейся с индекса $i$.
        \end{itemize}
\end{definition}

Рассмотрим на примере первые два шага алгоритма для строки $aba$:
\begin{gather*}
        0: \quad p = \{ 0, 2, 1 \} \quad c = \{ 0, 1, 0 \} \\
        1: \quad p = \{ 1, 2, 0 \} \quad c = \{ 1, 2, 0 \}
\end{gather*}

Теперь перейдём непосредственно к алгоритму. 
Рассмотрим нулевую фазу: на ней нам нужно отсортировать циклические подстроки размером $1$, т.е. отдельные
символы:
\begin{lstlisting}
std::vector<int> count(alphabetSize, 0);

for (int i = 0; i < s.length(); ++i) {
        ++count[s[i]];
}

for (int i = 1; i < alphabetSize; ++i) {
        count[i] += count[i - 1];
}

for (int i = 0; i < s.length(); ++i, --count[s[i]]) {
        p[count[s[i]]] = i;
}
\end{lstlisting}

Теперь нам нужно построить массив классов проходом по массиву $p$:
\begin{lstlisting}
classes[p[0]] = 0;

for (int i = 1, classIndex = 1; i < s.length(); ++i) {
        if (s[p[i]] != s[p[i - 1]]) {
                ++classIndex;
        }
        
        classes[p[i]] = classIndex - 1;
}
\end{lstlisting}
Далее пусть мы находимся на фазе $k$, выполнив при этом  $k-1$ фаз.
Заметим, что циклические подстроки размером  $2^{k}$ состоят из двух подстрок длины $2^{k - 1}$, которые
были обсчитаны на предыдущем шаге, мы можем это использовать. Взглянем на массив \lstinline{classes} с
предыдущего шага, в нём содержиться информация о подстроках длины $2^{k - 1}$, необходимая для их сравнения.
А именно пары вида \lstinline{(classes[i], classes[i + (1u << (k - 1))])}, 
т.е. элементы по индексу $i$ и $i + 2^{k-1}$. Осталось эти пары отсортировать. Заметим, что
подстроки длины $2^{k - 1}$ уже отсортированы на предыдущем шаге в массиве $p$.
Тогда мы можем получить сортировку половинок подстрок длины $2^{k}$ с помощью массива $p$.
Достаточко вычесть из каждого элемента массива $2^{k-1}$, ведь при переходе к строкам вдвое большей длины
эти подстроки становятся их вторыми половинками. После этого останется стабильной цифровой сортировкой
отсортировать по первому элементу пары и пересчитать массив \lstinline{classes}.

\begin{remark}
        Асимптотика алгоритма --- $O(n \log n)$.
\end{remark}
Действительно, нам нужно $O(n)$ на каждый шаг, а всего шагов --- $O(\log n)$.

\subsection{Алгоритм Касаи.}
\begin{tcolorbox}[sharp corners, colback=white, colframe=white!60!black, title=Важно!]
        В доказательстве корректности этого алгоритма довольно тяжело разобраться, если придерживаться
        математической строгости. Так что опустим это всё и разберёмся по сути.
\end{tcolorbox}

Этот алгоритм позволяет вычислять $LCP$ соседних суффиксов в суффиксном массиве за чудесные $O(n)$. 

\begin{enumerate}
        \item Для начала введём нужные обозначения, они будут очень похожи на обозначения с \href{https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D0%B0%D1%81%D0%B0%D0%B8_%D0%B8_%D0%B4%D1%80.}{neerc'а}, чтобы было проще разобраться потом. 
        \begin{itemize}
                \item $S$ --- наша строка.
                \item $S_{i}$ --- суффикс строки с $i$-ого символа.
                \item $Suf$ --- суффиксный массив. Сразу обговорим, что кроме индекса в элементе массива
                будет суффикс, соответствующий ему (далее будет показано на примере).
                \item $Suf^{-1}$ --- массив, обратный суффиксному. По сути, это просто массив суффиксов,
                отсортированный по длине суффикса, сразу покажем на примерe:
                \begin{figure}[H]
                        \caption*{Пример массивов для строки $abacaba$.}
                        \centering
                        \begin{minipage}{.5\textwidth}
                                \centering
                                \begin{tabular}{lrr}
                                        $i$ & $Suf[i]$ & $S_{Suf[i]}$ \\
                                        $0$ & $6$ & $a$ \\
                                        $1$ & $4$ & $aba$ \\
                                        $2$ & $0$ & $abacaba$ \\
                                        $3$ & $2$ & $acaba$ \\
                                        $4$ & $5$ & $ba$ \\
                                        $5$ & $1$ & $bacaba$ \\
                                        $6$ & $3$ & $caba$ \\
                                \end{tabular} 

                        \end{minipage}% 
                        \begin{minipage}{0.5\textwidth}
                                \centering
                                \begin{tabular}{lrr}
                                        $i$ & $Suf^{-1}[i]$ & $S_{i}$ \\
                                        $0$ & $2$ & $abacaba$ \\
                                        $1$ & $5$ & $bacaba$ \\
                                        $2$ & $3$ & $acaba$ \\
                                        $3$ & $6$ & $caba$ \\
                                        $4$ & $1$ & $aba$ \\
                                        $5$ & $4$ & $ba$ \\
                                        $6$ & $0$ & $a$ \\
                                \end{tabular} 
                        \end{minipage}%  
                \end{figure}
                На примере показано соответствие между массивами.
                Рассмотрим его ещё раз. Пусть мы зафиксировали элемент с $i = 1$ из массива $Suf$.
                Тогда $Suf[1] = 4$ и $S_{Suf[1]} = S_{4} = aba$, эта строка соответствует элементу
                $Suf^{-1}$ с индексом $j = 4$. Заметим, что $Suf^{-1}[4] = 1$, что равно изначальному
                взятому $i = 1$. Получается, $Suf^{-1}[i]$ показывает, на каком месте в массиве $Suf$
                находится $i$-ый суффикс.

                \item $LCP[x, z]$ --- длина наибольшего общего префикса строк $S_{x}, S_{z}$.
                        По сути, здесь индексы обозначают индексы в правой табличке из примера сверху.
                        Например, $LCP[0, 2] = LCP[abacaba, acaba] = 1$.
                \item $lcp[x, z]$ --- длина наибольшего общего префикса строк $S_{Suf[x]}, S_{Suf[z]}$.
                        Здесь же индексы аналогично обозначают индексы в левой табличке из примера сверху.
                        Например, $lcp[0, 2] = LCP[a, abacaba] = 1$.
        \end{itemize}
        \item Теперь рассмотрим три вспомогательных леммы. Все примеры далее будут использовать
                массивы для строки $abacaba$, описанные выше. Рекомендуется при разборе лемм держать эти
                таблички на виду, они пригодятся.

       \begin{lemma}
               \label{3.1}
               $lcp$ двух суффиксов --- минимум среди всех $lcp$ пар суффиксов между ними в массиве $Suf$.
               Или же:
               \[
                       lcp[y-1, y] \geq lcp[x, z], x < y \leq z
               .\] 
       \end{lemma}
       \begin{proof}
               Для начала приведём пример. Рассмотрим суффиксы из $Suf$ с $i = 1$ и  $i = 3$ 
               их $lcp[1, 3] = lcp[aba, acaba] = 1$. Теперь рассмотрим все пары суффиксов между ними:
               это пара с индексами $(1, 2)$ и $(2, 3)$, теперь посчитаем их  
               $lcp \colon lcp[1,2] = lcp[aba, abacaba] = 2, \text{ } lcp[2,3] = lcp[abacaba, acaba] = 1$. 
               Их минимум равен $1$, что совпадает с $lcp[1,3]$. Действительно, если  $lcp$ каких-либо 
               суффиксов $i, j$ из массива $Suf$ больше $lcp$ пары суффиксов между ними, то существует
               различающийся символ на позиции первых $lcp[i, j]$ символов, но из-за лексикографического
               порядка суффиксов это невозможно.
       \end{proof}
       
       \begin{lemma}
               \label{3.2}
               Рассмотрим суффиксы на позициях $x-1$ и $x$ в массиве $Suf$. 
               Пусть $lcp[x-1, 1] > 1$, тогда суффиксы, полученные удалением первого 
               символа, будут в том же лексикографическом порядке, что и изначальные.
               Простыми словами: если у соседних суффиксов $lcp > 1$, то удаление первого символа не
               изменит их порядок. Или же:
               \[
                       lcp[x-1, x] > 1 \implies Suf^{-1}[Suf[x-1] + 1] < Suf^{-1}[Suf[x] + 1]
               .\] 
       \end{lemma}
       \begin{proof}
               Для начала приведём пример. Рассмотрим суффиксы из $Suf$ с $i = 1$ и $j = 2$. 
               $lcp[1, 2] = lcp[aba, abacaba] = 2 > 1$, так что условие леммы выполняется.
               Теперь удалим первый символ у суффиксов, получим суффиксы $ba$ и  $bacaba$ c индексами
               $4$ и $5$ из массива $Suf$, т.е. порядок сохранился. Доказательство следует из того, что, 
               если суффиксы отсортированы в лексиграфическом порядке при двух совпадающих символах в 
               начале, то и при одном совпадающем символе они останутся отсортированы в лексиграфическом
               порядке. Осталось разобраться, почему формула в формулировке соответствует тому, что
               написано в доказательстве. Действительно, значения $Suf[x-1]$ и $Suf[x]$ равны индексам
               соответствующих суффиксов в массиве  $Suf^{-1}$, прибавление $1$ к ним означает <<спуск>>
               по массиву $Suf^{-1}$ вниз, что равносильно отсечению символу сначала (смотрите таблички), а
               обратное отображение $Suf^{-1}$ вернёт позиции урезанных на один символ суффиксов в массиве
               $Suf$. 
       \end{proof}
       \begin{lemma}
               \label{3.3}
               У двух соседних суффиксов в массиве $Suf$, у которых $lcp > 1$, при отсечении первого символа
               $lcp$ уменьшается на $1$. Или же:
               \[
                       lcp[x-1, x] > 1 \implies LCP[Suf[x-1] + 1, Suf[x] + 1] = lcp[x-1, x] - 1
               .\] 
               (обращаю внимание, что $LCP(x, y)$ --- длина наибольшего общего префикса строк 
               $S_{x}, S_{y}$, все обозначения есть выше). 
       \end{lemma}
       \begin{proof}
               Думаю, само утверждение не вызывает сомнений, осталось разобраться, почему это выражается
               такой формулой.  
               Действительно, значения $Suf[x-1]$ и $Suf[x]$ равны индексам
               соответствующих суффиксов в массиве  $Suf^{-1}$, прибавление $1$ к ним означает <<спуск>>
               по массиву $Suf^{-1}$ вниз, что равносильно отсечению символу сначала (смотрите таблички), а
               $LCP[Suf[x-1] + 1, Suf[x] + 1]$ --- формальная запись того, что мы рассматриваем суффиксы
               по данным индексам из нашего массива $Suf^{-1}$ (взгляните на таблички сверху).
       \end{proof}
      
       \item Докажем ещё одну вспомогательную лемму (на  \href{https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D0%B0%D1%81%D0%B0%D0%B8_%D0%B8_%D0%B4%D1%80.}{neerc'e}
                она соответствует лемме из пункта вспомогательные утверждения).
                
                Для начала введём новые обозначения (дублируют обозначения с \href{https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D0%B0%D1%81%D0%B0%D0%B8_%D0%B8_%D0%B4%D1%80.}{neerc'а}):
                \begin{itemize}
                        \item $i$ --- индекс рассматриваемого суффикса в массиве $Suf^{-1}$ 
                                (назовём этот суффикс первым).
                        \item $i - 1$ --- индекс соседнего с ним суффикса в массиве $Suf^{-1}$
                                (назовём этот суффикс вторым).
                        \item $q = Suf^{-1}[i]$ --- индекс первого суффикса в массиве $Suf$.
                        \item $p = Suf^{-1}[i - 1]$ --- индекс второго суффикса в массиве $Suf$. 
                        \item $j - 1 = Suf[p - 1]$ --- индекс в массиве $Suf^{-1}$ соседнего c вторым суффиксом
                                в массиве $Suf$. Действительно, $p$ --- индекс второго суффикса в массиве
                                $Suf$, тогда $p - 1$ --- индекс соседнего с ним в $Suf$, а
                                $Suf[p - 1]$ --- его индекс уже в массиве $Suf^{-1}$.
                        \item  $k = Suf[q - 1]$ --- аналогично индекс в массиве $Suf^{-1}$ соседнего с 
                                первым суффиксом в массиве $Suf$.
                \end{itemize}

                \begin{lemma}
                        \label{3.4}
                        $LCP$ суффикса и предыдущего суффикса из $Suf \geq LCP$ предшественника этого
                        суффикса из $Suf^{-1}$ и предыдущего суффикса (относительно предшественника) в
                        $Suf$ с удалёнными первыми элементами, если их изначальный $LCP > 1$. Или же:
                        \[
                                LSP(j-1, i-1) > 1 \implies LCP(k, i) \geq LCP(j, i) 
                        .\] 
                \end{lemma}
                \begin{proof}
                        Будем проводить доказательство паралелльно с примером, чтобы было нагляднее.
                        Пусть $i = 2$, что соответствует суффиксу $acaba$ из массива $Suf^{-1}$,
                        или же $S_{i} = acaba$ (смотрите табличку выше). Тогда $i - 1 = 1$, что
                        соответствует $S_{i-1} = bacaba$. $j - 1 = Suf[Suf^{-1}[i-1] - 1] = Suf[5 - 1] = 5$,
                        что соответствует суффиксу $ba$, который, как и говорилось, соседний с исходным
                        $bacaba$. Аналогично находим $k = 0$ и соответствующий суффикс  $abacaba$. 
                        Таким образом нашу лемму для конкретного случая можно записать так:
                        \[
                                LSP(\underbrace{j-1}_{=ba}, \underbrace{i-1}_{=bacaba}) > 1 \implies 
                                LCP(\underbrace{k}_{=abacaba}, \underbrace{i}_{=acaba}) 
                                \geq LCP(\underbrace{j}_{=a}, \underbrace{i}_{=acaba}) 
                        .\] 

                        Для начала заметим, что из \ref{3.2} и того, что в массиве $Suf$ суффиксы $S_{j-1}$ 
                        и $S_{i-1}$ соседние (это следует из определения $j-1$)
                        \[
                                LCP(\underbrace{S_{j-1}}_{=ba}, \underbrace{S_{i-1}}_{=bacaba}) > 1 \implies 
                                \underbrace{Suf^{-1}[j - 1 + 1]}_{=a} < 
                                \underbrace{Suf^{-1}[i - 1 + 1]}_{=acaba}
                        .\] 

                        Теперь заметим, что
                        \[
                                \underbrace{Suf^{-1}[k]}_{=abacaba} = \underbrace{Suf^{-1}[i]}_{=acaba} - 1     
                        .\] 
                        Т.е. мы берём предыдущий суффикс в $Suf$ перед $acaba$. Тогда получаем
                        \[
                                \underbrace{Suf^{-1}[j]}_{=a} \leq \underbrace{Suf^{-1}[k]}_{=abacaba} 
                                < \underbrace{Suf^{-1}[i]}_{=acaba}
                        .\] 
                        И наконец из \ref{3.1}
                        \[
                                LCP(\underbrace{j}_{=a}, \underbrace{i}_{=acaba}) \leq 
                                LCP(\underbrace{k}_{=abacaba}, \underbrace{i}_{=acaba})
                        .\] 
                \end{proof} 
        \item Теперь осталось доказать теорему, которая является комбинацией \ref{3.4} и \ref{3.3}. 
                \begin{theorem}[]
                        \label{3.5}
                        Формулировка очень похожа на \ref{3.4}
                        \[
                                LCP[(j-1, i-1) > 1 \implies LCP(k, i) \geq LCP(j-1, i-1) - 1
                        .\]          
                \end{theorem}
                \begin{proof}
                        Сначала из \ref{3.2} и условия нашей теоремы
                        \[
                                LCP(\underbrace{j}_{=a}, \underbrace{i}_{=acaba}) = 
                                LCP(\underbrace{j-1}_{ba}, \underbrace{i-1}_{bacaba}) - 1
                        .\] 
                        Совмещая с \ref{3.4}
                        \[
                                LCP(\underbrace{k}_{=abacaba}, \underbrace{i}_{=acaba}) 
                                \geq LCP(\underbrace{j}_{=a}, \underbrace{i}_{=acaba}) =
                                LCP(\underbrace{j-1}_{ba}, \underbrace{i-1}_{bacaba}) - 1
                        .\] 
                \end{proof}
\end{enumerate}

Теперь мы наконец-то можем перейти к практической реализации. Из теоремы \ref{3.5} мы получаем ограничение
снизу на значение $LCP$ от предыдущих вычисленных $LCP$. Тогда мы можем последовательно рассматривать
все суффиксы по порядку от $S_1$ до $S_{k}$, используя при этом $LCA$, посчитанное ранее. Ниже приведена
реализация, основанная на этом неравенстве.

\begin{lstlisting}
std::string s;
int length = s.length;
std::vector<int> sufArr; // суффиксный массив(считаем, что мы его заполнили)
std::vector<int> lcp; // то, что мы заполняем

void countLCP() { //Kasai
  std::vector<int> pos(length);
  for (int i = 0; i < length; ++i) {
    pos[sufArr[i]] = i;
  }
  int k = 0;
  for (int i = 0; i < length; ++i) {
    if(k > 0) {
      --k;
    }
    if(pos[i] == length - 1){
      lcp[pos[i]] = -1;
      k = 0;
    } else {
      int j = sufArr[pos[i] + 1];
      while (std::max(i + k, j + k) < length && s[i + k] == s[j + k])
        ++k;
      lcp[pos[i]] = k;
    }
  }
}
\end{lstlisting}

\begin{remark}
        Асимптотика данного алгоритма $O(n)$.
\end{remark}
Это следует из того, что на каждой итерации значение $LCP$ может уменьшиться не более, чем на единицу
(следует из \ref{3.5}), тогда всего значение $LCP$ увеличиться не более, чем на $O(2n)$, а каждое увеличение
происходит за  $O(1)$.
