\begin{tcolorbox}[sharp corners, colback=white, colframe=white!60!black, title=Важно!]
  Прошу обратить внимание, что это не конспект лекций, а конспект курса. Большая часть информации
  взята с Кормена, emaxx, neerc и других источников.
\end{tcolorbox}
\lecture{1}{Поиск строк}

\subsection{Основные понятия.}

Рассмотрим задачу поиска подстрок. Формализуем её следующим образом.
\begin{remark}
	Пусть текст задан в виде массива $T[1 \ldots n]$, а образец (шаблон) --- в виде массива
	$P[1 \ldots m]$, где $m \leq n$. Причём элементы массивов --- символы из конечного алфавита. 
\end{remark}

\begin{definition}
Символьные массивы $P$ и $T$ называют \highlight{строками символов}.
\end{definition}

Пусть $\Sigma$ --- конечный алфавит, а $\Sigma^{*}$ --- множество всех строк конечной длины, образованных
с помощью этого алфавита, тогда введём некоторые формальные определения.

\begin{definition}
	\highlight{$\omega$} --- префикс строки $x$ (обозначается как $ \omega \sqsubset x$), если $x = \omega y$
	для некоторого $y \in \Sigma^{*}$ 
\end{definition}

\begin{definition}
	\highlight{$ \omega$} --- суффикс строки $x$ (обозначается как $ \omega \sqsupset x$), если $x = y \omega $
	для некоторого $y \in \Sigma^{*}$ 
\end{definition}

\begin{remark}
	Префикс (суффикс) может быть собственным, это означает, что он не совпадает с самой строкой.
\end{remark}

\subsection{Постановки задачи поиска. Тривиальный алгоритм поиска подстроки в строке.}
Для начала дадим несколько вспомогательных определений.
\begin{definition}
	\highlight{$P$ встречается в тексте $T$ со сдвигом $s$}, если $0 \leq s \leq n - m$ и $T[s + j] = P[j]$ 
	 для $1 \leq j \leq m$
\end{definition}

\begin{definition}
	\highlight{$s$ --- допустимый сдвиг}, если $P$ встречается в $T$ со сдвигом $s$.
\end{definition}

\begin{remark}
	Задача поиска подстроки таким образом представляет собой задачу поиска всех допустимых сдвигов
\end{remark}

Рассмотрим тривиалный алгоритм поиска подстроки в строке

\begin{lstlisting}
	n = T.size();
	m = P.size();
	for (size_t s = 0; s < n - m; ++s) {
		if (T.substr(s + 1, s + m) == P) {
			std::cout << s << std::endl;
		}
	}
\end{lstlisting}

\begin{remark}
	Очевидно, что время его работы равно $O((n - m + 1)m)$, что в худшем случае ($m = \frac{n}{2}$) равно
	$O(n^2)$.
\end{remark}

\subsection{Префикс-функция. Тривиальный алгоритм нахождения.}

\begin{definition}
	\highlight{Префикс-функция} --- массив чисел $\pi [0 \ldots n-1]$, где $\pi [i]$ --- наибольшая длина наибольшего
	собственного суффикса подстроки $s[0 \ldots i]$, совпадающего с её префиксом. Или же
	 \[
		 \pi[i] = \max \{ k \colon (k < i) \wedge (s[0 \ldots k-1] = s[i - k + 1 \ldots i] \}
	\]
	$\pi[0]$ положим равной нулю.
\end{definition}

Например, у подстроки abca строки abcabcd префикс длины 1 совпадает с суффиксом, т.е. $\pi [3] = 1$

Исходя из определения можно написать простейший алгоритм

\begin{lstlisting}
	std::vector<int> prefix(std::string& s) {
		std::vector<int> pi(s.length());

		for (size_t i = 0; i < s.length(); ++i) {
			for (size_t k = 0; k <= i; ++k) {
				if (s.substr(0, k) == s.substr(i - k + 1, k)) {
					pi[i] = k;
				}
			}
		}
	}
\end{lstlisting}

\begin{remark}
	Очевидно, что его асимптотика $O(n^3)$.
\end{remark}

\subsection{Линейный алгоритм нахождения. Доказательство времени работы.}

Оптимизируем наш простейший алгоритм. Для начала заметим, что префикс функция увеличивается не более, чем
на единицу, т.е. $\pi [i + 1] - \pi [i] \leq 1$. Т.е. могло произойти не более $n$ увеличений функции (каждый
раз увеличение не более чем на $1$) и, соответственно, не более $n$ уменьшений.

\begin{remark}
	Алгоритм может иметь асимптотику $O(n^2)$
\end{remark}
Действительно, достаточно заметить, что нам нужно произвести $O(n)$ сравнений строк (сравнение необходимо только
при увеличении/уменьшении префикс-функции).

Далее нужно как-то избавиться от тяжёлой операции сравнения подстрок. \textbf{Но как это сделать?} Будем
использовать то, что мы уже посчитали.

\begin{remark}
	Если $s[i + 1] = s[\pi [i]]$, то $ \pi [i+1] = \pi [i] + 1$
\end{remark}
Доказательство легко видно на рисунке
\[
	\underbrace{\overbrace{s_1 s_2}^{\pi [i]} \overbrace{s_3}^{s_3 = s_{i+1}}}_{\pi[i+1]} \ldots \overbrace{s_{i-1} s_{i}}^{\pi[i]} s_{i+1} 
\] 
А что делать, если $s[i+1] \neq s[\pi[i]]$? Тогда попробуем рассмотреть суффикс поменьше длиной $k$ и проверить, 
существует ли равный ему префикс, в таком случае, если мы найдем максимальное такое $k$, то нам останется
проверить равенство $s[i+1] = s[k]$.

Покажем на примере
\[
	\overbrace{\underbrace{s_0 s_1}_{k} s_2 s_3}^{\pi [i]} \ldots \overbrace{s_{i-3} s_{i-2} \underbrace{s_{i-1} s_{i}}_{k}}^{\pi [i]}
\] 

\begin{remark}
	$k = \pi[\pi[i] - 1]$ (вычитание единицы из-за нумерации строк с 0)
\end{remark}

Это легко вытекает из предыдущего рисунка, действительно, если мы рассмотрим суффикс длины $\pi [i]$ и найдём 
в нём ещё один суффикс, отвечающий нашему условию, то мы получим требуемое.

Таким образом, получим итоговый алгоритм:

\begin{enumerate}
	\item Считаем $\pi [i]$ от $i = 1$ до $i = n - 1$
	\item Тестируем образец длины $j$ по описанной выше схеме
	\item Останавливаем перебор при $j = 0$
\end{enumerate}

\begin{lstlisting}
	std::vector<int> prefix(std::string &s) {
		std::vector<int> pi(s.length());

		for (size_t i = 1; i < s.length(); ++i) {
			size_t j = pi[i - 1];
			while (j > 0 && s[i] != s[j]) {
				j = pi[j - 1];
			}
			if (s[i] == s[j]) ++j;
			pi[i] = j;
		}
		return pi;
	}
\end{lstlisting}

\begin{remark}
	Представленный алгоритм работает за $O(n)$
\end{remark}

\subsection{Подсчёт префикс-функции для строки q\$t. Алгоритм Кнута-Морриса-Пратта.}

Пусть $\left| q \right| = n, \left| t \right| = m$. Рассмотрим значение префикс-функции в таком случае.

\begin{remark}
	Значения $\pi [i]$ при $i > n$ равны $0$, а равенство $\pi[i] = n$ означает окончание вхождения искомого
	паттерна.
\end{remark}

Таким образом получаем алгоритм Кнута-Морриса-Пратта. Т.к. значение префикс-функции не может превысить $n$ мы
можем хранить только искомую строку (следует из самого алгоритма описанного выше). Таким образом получаем требуемую асимптотику.

\begin{remark}
	Алгоритм Кнута-Морриса-Пратта работает за $O(n+m)$ и $O(n)$ памяти.
\end{remark}

\subsection{Z-функция. Тривиальный алгоритм нахождения.}

\begin{definition}
	\highlight{$Z$-функция строки $s$} --- массив длины $n$ ($\left| s \right| = n$), где $z[i]$ --- длина
  наибольшего общего
	префикса строки $s$ и её $i$-ого суффикса.
\end{definition}

Рассмотрим тривиальный алгоритм, который перебирает ответ для каждого $i$

\begin{lstlisting}
	std::vector<int> zFunction(std::string& s) {
		std::vector<int> z(s.length());

		for (size_t i = 1; i < s.length(); ++i) {
			while ((i + z[i] < n) && (s[z[i]] == s[i + z[i])) {
				++z[i];
			}
		}
		return z;
	}
\end{lstlisting}

\begin{remark}
	Асимптотика такого алгоритма, очевидно, $O(n^2)$
\end{remark}

\subsection{Линейный поиск Z-функции. Доказательство времени работы.}

Для оптимизации алгоритма воспользуемся тем же, т.е. будет использовать вычисленные значения.

\begin{definition}
	\highlight{Отрезок совпадения} --- подстрока, совпадающая с префиксом строки $s$
\end{definition}
Например, для строки abab, ab --- отрезок совпадения.

Будем вычислять значения $z$-функции по очереди от $i = 1$ до $n - 1$ и хранить значения $[l;r]$ самого правого
отрезка совпадения, т.е. $r$ указывает нам на правую границу, до которой просканировал алглоритм.

Далее на некотором $i$-ом шаге возможно два случая:
\begin{itemize}
	\item $i>r$, тогда нам ничего не известно про следующие символы, т.к. они не были просканированы
		алгоритмом, так что запустим тривиальный алгоритм от этого $i$, после чего (если $z[i] > 0$)
		обновим значения $[l;r]$ 
	\item $i \leq r$, тогда мы можем инициализировать значение $z[i]$ чем-то большим $0$. Рассмотрим на
		примере.
\end{itemize}

\begin{remark}
	В случае $i \leq r$ можно проинициализировать $z[i]$ таким образом, а далее аналогичным образом запустить
	тривиальный алгоритм поиска.
	\[
		z[i] = \min \left( r - i + 1, z[i-l] \right) 
	\] 
\end{remark}

Доказательство этого утверждения увидим на рисунке

\[
	a_1 a_2 a_3 \underbrace{\overbrace{a_4}^{i-l} a_5}_{z[i-l]} \ldots a_{l} a_{l+1} a_{l + 2} \underbrace{a_{i} a_{r}}_{z[i-l]} 
\] 

Т.к. мы знаем, что $[l;r]$ --- отрезок совпадения, а $z[i-l]$ мы уже посчитали, то для начального инициализации
можно будет использовать посчитанное значение. Ограничение в $r - i + 1$ нужно для того, чтобы повторяющийся
кусок не вышел за границы $r$, т.к. мы ничего не знаем о символах после $r$.

Приведём реализацию:

\begin{lstlisting}
	std::vector<int> zFunction (std::string& s) {
		int l = 0, r = 0;
		std::vector<int> z(s.length());

		for (int i = 0; i < s.length(); ++i) {
			if (i <= r) {
				z[i] = std::min(r - i + 1, z[i - l];
			}
			
			while ((i + z[i] < n) && (s[z[i]] == s[i + z[i]])) {
				++z[i];
			}

			if (i + z[i] - 1 > r) {
				l = i;
				r = i + z[i] - 1;
			}
		}
		return z;
	}
\end{lstlisting}

\begin{remark}
	Асимптотика данного алгоритма $O(n)$
\end{remark}

\begin{proof}
	Достаточно рассмотреть цикл $while$, т.к. остальные операции выполняются за константу. Заметим что при
	$i > r$ каждая итерация цикла продвигает $r$ вправо (кроме случаев, когда $s[0] \neq s[i]$, тогда
	вовсе не будет итераций цикла $while$. Если же $i \leq r$, итерация цикла либо продвинет $r$, либо
	не случится вовсе. В таком случае, итераций цикла $while$ будет не более $n$ штук.
\end{proof}

\subsection{Применение для поиска подстроки в строке.}

Применение и оптимизация памяти аналогично префикс-функции.
