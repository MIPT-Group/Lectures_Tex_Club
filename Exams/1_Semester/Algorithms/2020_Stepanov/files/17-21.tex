\setcounter{section}{16}
\section{Поиск $k$-й порядковой статистики с выбором случайного пивота с доказательством времени работы}

\subsection*{Поиск $k$-ой порядковой статистики с помощью выбора пивота. Разделяй и властвуй.}

\noindent\textbf{Определение}{K-ой порядковой статистикой называется элемент, который окажется на K-ой позиции после сортировки массива.}

Назовем нашу функцию KStatDC( A, n, K ).

\textit{Partition и пивот из 16 билета}

\begin{enumerate}
    \item Выбираем пивот, вызываем Partition.
    \item \begin{itemize}
        \item Если $P == K$, то пивот является K-ой порядковой статистикой
        \item Если $P > K$, то к-я порядковая статистика находится слева. Вызываем $KStatDC(A, n-P, K)$ 
        \item Если $P < K$, то k-я порядковая статистика находится справа, вызываем $KStatDC(A + (P + 1), n - (P + 1), K - (P+1))$
    \end{itemize}
\end{enumerate}
\noindentВремя работы
\begin{itemize}
    \item $T(n) = O(n)$ в лучшем
    \item $T(n) = O(n)$ в среднем
    \item $T(n) = O(n^2)$ в худшем
\end{itemize}

\textbf{Доказательство}

\parbox[t]{0.95\linewidth}{
    (Доказательство среднего времени работы)
    \\
    Будем оценивать количество сравнений. При поиске статистики в массиве размера $n$ функция partition (точнее, одна из распространённых вариаций) совершает не более $n - 1$ сравнений. Далее, в зависимости от $k$ выбирается левая или правая половины (или вообще алгоритм завершает работу). Оценку проводим сверху, то есть, будем считать, что каждый раз выбирается большая половина.

    $$\begin{gathered}
    T(n) \le \frac 1n \sum\limits_{k = 1}^n \left ( T \left ( \max \left \{k - 1; n - k \right \} \right ) + n - 1 \right ) = n - 1 + \frac 1n \sum\limits_{k = 1}^n T(\max \{k - 1; n - k\}) = \\ = n - 1 + \frac 2n \sum\limits_{k = \lfloor n/2 \rfloor}^{n - 1} T(k)
    \end{gathered}$$
    
    Предположим, что $T(k) \le ck$ для некоторой константы $c$ и всех $k < n$ (будем доказывать оценку по индукции). Тогда верно неравенство:
    
    $$T(n) = n - 1 + \frac 2n \sum\limits_{k = \lfloor n/2 \rfloor}^{n - 1} ck$$
    
    Преобразуем сумму из правой части равенства по формуле суммы арифметической прогрессии и оценим преобразованное выражение:
}

\parbox[t]{0.95\linewidth}{
    $$\sum\limits_{k = \lfloor n/2 \rfloor}^{n - 1} ck = \frac 12 \left(\left \lceil \frac n2 \right \rceil  \right) \left( c \left \lfloor \frac n2 \right \rfloor + c(n - 1) \right) \le \frac c2 \left(\frac{n + 1}2 \right) \frac{3n - 2}2 = c \frac{n + 1}4 \frac{3n - 2}2$$
    
    Воспользуемся полученной оценкой для оценки исходного выражения. Также, предположим, что $c \ge 4$:
    
    $T(n) \le n - 1 + \frac{2c}n \frac{n - 1}4 \frac{3n - 2}2 = n - 1 + c\frac{n - 1}{2n} \frac{3n - 2}2 \le \frac c4 (n - 1) + \frac c4\left(\frac{n - 1}n (3n - 2)\right) \le$
    $\frac c4 (n - 1 + 3n - 2) = \frac c4 (4n - 3) \le cn$
    
    Для завершения доказательства необходима проверка базы индукции, но она тривиальна: для выборки порядковой статистики из одного элемента сравнений не требуется: $T(1) = 0 < 4$. Итого, мы доказали, что $T(n) \le 4n$, следовательно, $T(n) = O(n)$
}

\setcounter{section}{17}
\section{Детерминированный алгоритм поиска k-й порядковой статистики за O(n), где n - длина массива}

\subsubsection*{Поиск K-ой порядковой статистики за линейное время}
Назовем функцию KStatLin( A, n, K ).
\begin{enumerate}
    \item Разобьем массив на пятерки.
    \item Сортируем каждую пятерку, выбираем медиану из каждой пятерки.
    \item Ищем M – медиану медиан пятерок, вызвав KStatLin( Medians, n/5, n/10 ).
    \item Разделяем по пивоту M, вызывая обычный Partition.
    \item Далее аналогично предыдущему алгоритму
\end{enumerate}

\textbf{Утверждение} Время работы алгоритма $T(n) = O(n)$

\textbf{Доказательство}

Время работы не больше чем сумма:
\begin{enumerate}
    \item Времени работы на сортировку групп и разбиение по рассекающему элементу, то есть $Cn$
    \item Времени работы для поиска медианы медиан, то есть $T\left( \frac{n}{5}\right)$
    \item времени работы для поиска $k$-го элемента в одной из двух частей массива, то есть $T(s)$, где $s$ — количество элементов в этой части. Но $s$ не превосходит $\dfrac{7n}{10}$, так как чисел, меньших рассекающего элемента, не менее $\dfrac{3n}{10}$ — это $\dfrac{n}{10}$ медиан, меньших медианы медиан, плюс не менее $\dfrac{2n}{10}$ элементов, меньших этих медиан. С другой стороны, чисел, больших рассекающего элемента, так же не менее $\dfrac{3n}{10}$, следовательно  $ s \leqslant $ $\dfrac{7n}{10}$, то есть в худшем случае $ s = $ $\dfrac{7n}{10}$. 
\end{enumerate}

\parbox[t]{0.95\linewidth}{
    Тогда получаем, что  $T(n) \leqslant T$ $\left(\dfrac{n}{5}\right)$$ + T$ $\left(\dfrac{7n}{10}\right)$$ + Cn $
    \\
    Покажем, что для всех $ n $ выполняется неравенство $T(n) \leqslant 10Cn $.
    \\
    Докажем по индукции: 
    \begin{enumerate}
      \itemПредположим, что наше неравенство $T(n) \leqslant 10Cn $ выполняется при малых $ n $, для некоторой достаточно большой константы $ C $. 
      \item Тогда, по предположению индукции, $T$$\left(\dfrac{n}{5}\right)$ $ \leqslant 10C $$\dfrac{n}{5}$ $ = 2Cn$ и $ T$$\left(\dfrac{7n}{10}\right)$ $ \leqslant 10C $$\dfrac{7n}{10}$ $ = 7Cn$, тогда
      $T(n) \leqslant T$$\left(\dfrac{n}{5}\right)$ $ +  T$$\left(\dfrac{7n}{10}\right)$ $ +  Cn = 2Cn + 7Cn + Cn = 10Cn \Rightarrow T(n) \leqslant 10Cn$
    \end{enumerate}
    
    Так как $T(n) \leqslant 10Cn $, то время работы алгоритма $O(n)$
}

\setcounter{section}{18}
\section{Детерминированный алгоритм быстрой сортировки за O(n log n), где n - длина массива.}

\noindent \textbf{Определение} Если $a_1, \dots, a_n$ - массив, то его медианой называется $\frac{n + 1}{2}$ статистика, если n нечетно и полусумма $\frac{n}{2}$ и $\frac{n + 2}{2}$ статистик, если четное.

\textit{Модификация: в качестве пивота выбираем медиану}

\lstinputlisting[language=C++,
emph={int,char,double,float,unsigned},
emphstyle={\color{blue}}
]{code/17-21_detstablesort.cpp}

$T(n)$ - время работы алгоритма для массива длины $n$.

$T(n) = 2T(\frac{n + 1}{2}) + O(n) = O(nlog(n))$
($O(n)$ здесь поиск медианы $+$ Partition)

\setcounter{section}{19}
\section{Стабильная сортировка подсчетом}

\textbf{Задача} Отсортировать массив $A[0\ldots n-1]$, содержащий неотрицательные целые числа меньшие k.

\textbf{Определение} Сортировка называется стабильной, если для равных элементов массива $a[i] = a[j], i < j$ после сортировки элемент $a[i]$ идет раньше элемента $a[j]$.

\textbf{Решение 1}
\begin{itemize}
    \item Заведем массив $C[0\ldots k-1]$, посчитаем в $C[i]$ количество вхождений элемента i в массиве A
    \item Выведем все элементы $\{0\ldots k\}$ по $C[i]$ раз
\end{itemize}

\textbf{Решение 2(карманная сортировка подсчетом)}
\begin{itemize}
    \item Заведем массив $C[0\ldots k-1]$, посчитаем в $C[i]$ количество вхождений элемента i в массиве A
    \item Вычислим границы групп элементов для каждого $i \in \{0,\ldots,k\}$(начальные позиции каждой группы). (Просто массив префиксных сумм)
    \item Создадим массив для результата B
    \item Переберем массив A. Очередной элемент A[i] разместим в B в позиции $C[A[i]]$. Сдвинем текущую границу группы.
    \item Скопируем B в A
\end{itemize}

\lstinputlisting[language=C++,
emph={int,char,double,float,unsigned},
emphstyle={\color{blue}}
]{code/17-21_19cs2.cpp}

\textbf{Замечание.} Сортировка подсчетом - стабильная, но не локальная

Время работы $T(n,k) = O(n+k)$
//
Дополнительная память $T(n,k) = O(n+k)$

\setcounter{section}{20}
\section{Цифровая сортировка}

Если диапазон значений велик, то сортировка подсчетом не годится.
Строки, целые числа можно разложить на разряды. Диапазон значений разряда довольно мал. Можно выполнять сортировку массива по одному разряду, используя сортировку подсчетом.


\textbf{Замечание.} LSD - Least Significant Digit

Сначала сортируем подсчетом по младшим разрядам, затем по старшим. Ключи с различными младшими разрядами, но одинаковыми старшими не будут перемешаны при сортировки старших разрядов благодаря
стабильности поразрядной сортировки.

\lstinputlisting[language=C++,
emph={int,char,double,float,unsigned},
emphstyle={\color{blue}}
]{code/17-21_20digitsort.cpp}

Время работы $T(n,k,r) = O(r(n+k))$
\\
Дополнительная память  $M(n,k,r) = O(n+k)$
\\
где n - размер массива, k - размер алфавита, r - количество разрядов.