\setcounter{section}{33}
\section{Структура данных вектор, реализация на массиве и оценка асимптотики двумя способами.}

Vector - это массив, который умеет делать доступ к $i$-тому элементу за $O(1),$ позволяет добавлять элемент в конец, позволяет удалять элемент из конца.
\begin{lstlisting}
class vector<T> {
    T* data;
    size_t s; // size
    size_t c; // capacity
public:
    T operator[](size_t index) const;
    void push_back(const T& elem);
    void pop_back();
    ...
};
\end{lstlisting}
Операции $push\_back$ и $pop\_back$ будут выполняться за $O(1)^*$ (аммортизированное, оно же учётное, оно же приведённое время).

\textbf{Типовая реализация.}

Внутри храним массив по указателю $data$, размера $c,$ который не полностью заполнен (используется только первые $s$ элементов).

Типичный $push\_back$: дописываем в конец один элемент и увеличиваем $s$ на 1. Однако если $s = c,$ то расширяем массив в 2 раза и перекопируем $s$ элементов в начало нового массива.

Типичный $pop\_back$: уменьшаем $s$ на 1. Однако если $s = c/4,$ то сужаем массив в 2 раза и перекопируем $s$ элементов в начало нового массива.

\textbf{Доказательство 1 (методом амортизационного анализа).}

Всегда выполняется неравенство: $c/4 < size \leq c.$
Рассмотрим две соседнии "тяжёлые" операции (для которых требуется менять размер массива).

Случай 1. Пусть эти обе операции $push\_back.$ В первой операции $c\to 2c,$ во второй $2c\to 4c.$ Тогда между этими операциями не менее $2c-c=c$ лёгких запросов.

Случай 2. Сначала был $push\_back,$ затем $pop\_back.$ В первой операции $c\to 2c,$ во второй $2c\to c.$ Тогда между этими операциями не менее $c-2c/4=c/2$ лёгких запросов.

Остальные случаи аналогично. В любом случае два тяжёлых запроса разнесены на $\alpha c,$ где $\alpha$ - константа. Лёгкие запрос стоят по $O(1)$. Тогда вместе с последующим тяжёлым запросом, мы получаем стоимость, пропорциональную количеству лёгких запросов, т.е. в среднем по $O(1)$ на запрос.

\textbf{Доказательство 2 (методом монеток).}

При операции $push\_back,$ которая помещает элемент на $i$-тую позицию, положим по одной монетке в позиции $i$ и $i-c/2.$ (Если $i-c/2 < 0,$ то вторую монетку не используем.)

При операции $pop\_back,$ которая удаляет элемент в $i$-той позиции, положим монетку в позицию $i-c/4.$

Рассмотрим две соседнии тяжёлые операции.

Случай 1. Пусть эти обе операции $push\_back.$ В первой операции $c\to 2c,$ во второй $2c\to 4c.$ Между ними, мы были вынуждены положить хотя бы по одной монетке на все позиции от $0$ до $2c.$ Когда нам нужно расширить массив $2c\to 4c$, то у нас в банке уже достаточно монет для оплаты тяжёлого $push\_back.$ Для лёгкого запроса: $d=2, w=0, t=1.$ Для тяжёлого запроса: $d=0, t=w=2c.$

Случай 2. Пусть эти обе операции $pop\_back.$ Для того, чтобы вызвать второй $pop\_back,$ мы должны удалить элементы с позиций от $c/2$ до $c/4,$ тем самым положив по монетки в позиции от $c/4$ до $0.$ Когда нам нужно сузить массив до $c/2\to c/4,$ то в банке уже достаточно монет для оплаты тяжёлого $pop\_back.$ Для лёгкого запроса: $d=1, w=0, t=1.$ Для тяжёлого запроса: $d=0, t=w=c/4.$

Остальные случаи аналогично.

Следовательно: $a=d+t-w=O(1)$ в рамках бухлалтерского учёта. Также наша конструкция гарантирует, что в банке всегда есть монетки. Поэтому, амортизационная стоимость $O(1)^*,$ т.е. любые $n$ операций выполняются за $O(n).$