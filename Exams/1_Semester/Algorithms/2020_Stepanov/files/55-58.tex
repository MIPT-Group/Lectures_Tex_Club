 
\newpage
\setcounter{section}{54}
\section{Декартово дерево: определение и теорема о глубине (б/д)}

\noindent\textbf{Определение} Декартово дерево ― двоичное дерево, в узлах которого
хранится пары $(x, y)$ , где x – это ключ, а y – это приоритет (значение). Все x и все y
являются различными. Если некоторый элемент дерева содержит ($x_0$, $y_0$),
то у всех элементов в левом поддереве $x < x_0$, у всех элементов в правом
поддереве $x > x_0$, а также и в левом, и в правом поддереве $y < y_0$.
\\

\textbf{Это дерево поиска по ключам $x$ и куча по приоритетам $y$}
\\

\noindent\textbf{Теорема} В декартовом дереве из n узлов, приоритеты которого являются случайными величинами с равномерный распределением, средняя глубина дерева O(log(n)). Без доказательства.


\subsection*{Построение за O(n), если ключи упорядочены. Вероятно, оно не нужно, но я оставлю. Можете пропустить, если хотите.}

\parbox[t]{0.95\linewidth}{
Будем строить дерево слева направо, то есть начиная с $(x_1, y_1)$ по $(x_n, y_n)$, при этом помнить последний добавленный элемент $(x_k, y_k)$. Он будет самым правым, так как у него будет максимальный ключ, а по ключам декартово дерево представляет собой двоичное дерево поиска. При добавлении $(x_{k+1}, y_{k+1})$, пытаемся сделать его правым сыном $(x_k, y_k)$, это следует сделать если $y_k > y_{k+1}$, иначе делаем шаг к предку последнего элемента и смотрим его значение $y$. Поднимаемся до тех пор, пока приоритет в рассматриваемом элементе меньше приоритета в добавляемом, после чего делаем $(x_{k+1}, y_{k+1})$ его правым сыном, а предыдущего правого сына делаем левым сыном $(x_{k+1}, y_{k+1})$.
\newline
Заметим, что каждую вершину мы посетим максимум дважды: при непосредственном добавлении и, поднимаясь вверх (ведь после этого вершина будет лежать в чьем-то левом поддереве, а мы поднимаемся только по правому). Из этого следует, что построение происходит за $O(n)$.
}

\setcounter{section}{55}
\section{Реализация операций merge и split в Декартовом дереве}

\begin{itemize}
    \item Основные операции: 
    \begin{itemize}
        \item Разрезание - Split
        \item Слияние - Merge
    \end{itemize}
    \item На основе этих двух операций реализуются операции:
    \begin{itemize}
        \item Вставка - Insert
        \item Удаление - Delete (Decrease)
    \end{itemize}
\end{itemize}

\subsubsection*{Разрезание - Split}

\textbf{Задача} Дано декартово дерево T, ключ K. Нужно разделить дерево T на $T_1$ и $T_2$ так, чтобы в $T_1$ находились все ключи меньшие K, а в $T_2$ больше, либо равные.
\newline

\textbf{Идея:}
Функция рекурсивная. Смотрим на значение в вершине. Если оно меньше $K$, то эта вершина вместе с левым ее поддеревом будет принадлежать дереву $T_1$. Запустимся от правого поддерева. Нам вернут два дерева $RightT_1$ и $RightT_2$. Далее нам нужно $RightT_1$ сделать правым сыном текущей вершины. Таким образом, в результате мы получим два дерева - $T1$ (корень которого - наша вершила, левое поддерево не менялось, а правое мы получили после рекурсивного запуска функции) и $RightT_2$, которые нам и нужно будет вернуть как результат работы функции. Аналогично, если значение в корне больше, либо равно $K$.
\newline
\textbf{Решение.}

\begin{lstlisting}
    template <typename ValueType>
    std::pair<std::shared_ptr<Node>,
              std::shared_ptr<Node>>
    Treap<ValueType>::Split(std::shared_ptr<Node> node, ValueType value) {
      if (!node) {
        return {nullptr, nullptr};
      }
    
      if (value > node->value) {
        auto [left, right] = Split(node->right_child, value);
        node->right_child = left;
        return {node, right};
      } else {
        auto [left, right] = Split(node->left_child, value);
        node->left_child = right;
        return {left, node};
      }
    }
\end{lstlisting}

\textbf{Задача} Дано два декартовых дерева $T_1$ и $T_2$. Причем все ключи $T_1$ меньше ключей $T_2$. Нужно объединить их в одно декартово дерево.
\newline

\textbf{Идея:} Сравниваем корни наших деревьев $v_1$ и $v_2$. Пусть левый корень имеет меньший приоритет (в противоположном случае аналогичное решение). Тогда все дерево $T_1$ будет лежать в левом поддереве дерева $T_2$ Тогда мы должны сделать Merge T1 и левого сына вершины $v_2$. После чего результат подвесить в качестве нового левого сына к $v_2$.
\newline

\textbf{Решение.} (Функция Merge)
\begin{lstlisting}
    template <typename ValueType>
    std::shared_ptr<Node> Treap<ValueType>::Merge(
        std::shared_ptr<Node> left_tree,
        std::shared_ptr<Node> right_tree) {
      if (!left_tree) {
        return right_tree;
      }
      if (!right_tree) {
        return left_tree;
      }
    
      if (left_tree->priority > right_tree->priority) {
        left_tree->right_child = Merge(left_tree->right_child, right_tree);
        return left_tree;
      } else {
        right_tree->left_child = Merge(left_tree, right_tree->left_child);
        return right_tree;
      }
    }
\end{lstlisting}

\setcounter{section}{56}
\section{Выражение операций insert и erase через merge и split}

\textbf{Задача} Дано декартово дерево $T$ и ключ $K$. Нужно вставить ключ в дерево.

\textbf{Решение.}
\begin{enumerate}
    \item Сначала спускаемся по дереву (как в обычном бинарном дереве поиска), но останавливаемся на первом элементе, в котором значение приоритета оказалось меньше y.
    \item Теперь разрезаем поддерево найденного элемента на $T_1$ и $T_2$.
    \item Полученные $T_1$ и $T_2$ записываем в качестве левого и правого сына добавляемого элемента.
    \item Полученное дерево ставим на место элемента, найденного в первом пункте
\end{enumerate}

\textbf{Задача} Дано декартово дерево T и ключ K. Нужно удалить узел с ключом K, если такой есть.


\textbf{Решение.}
\begin{enumerate}
    \item Сначала спускаемся по дереву (как в обычном бинарном дереве поиска), ища удаляемый элемент
    \item Найдя элемент, вызываем слияние его левого и правого сыновей
    \item Результат merge ставим на место удаляемого элемента
\end{enumerate}

\setcounter{section}{57}
\section{Декартово дерево по неявному ключу. В массиве вставить, удалить элемент, узнать сумму на отрезке}

\textbf{Задача} Пусть у нас есть массив $a$ из $n$ элементов.
Требуется уметь выполнять следующие операции: \\
1) Insert(x, pos) - вставить элемент x после элемента с позицией pos. \\
2) Erase(pos) - удалить элемент с позицией pos. \\
3) Посчитать сумму элементов с l по r.
\newline
Реализация через декартово дерево.
У нас нет ключей, так что выдумаем их сами. "Ключом" будем считать  кол-во элементов левее данного. 
$T.size()$ - количество вершин в поддереве
Тогда ключ для данной вершины - количество вершин в левом поддереве. \\

Merge будет как в обычном декартовом дереве, но с поддержкой значения $T.size()$

Split будет по количеству $k$ элементов, которые должны в итоге быть в левом поддереве.

Также будем хранить сумму элементов в поддереве. Обновлять ее несложно. \\

На третий запрос отвечаем след. образом: делаем

1) split(l)

2) split(r - l) от правого из полученных деревьев

3) возвращаем сумму в центральном из трех деревьев

4)merge, чтобы склеить все обратно