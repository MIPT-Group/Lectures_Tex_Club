\setcounter{section}{6}
\section{Реализация очереди на двух стеках.}
Очередь: принцип first in - first out, операции: добавить в конец, посмотреть/удалить элемент из начала. \par
Заводим два стека: первый стек - del, второй - add. Из первого стека происходит удаление элементов, во второй стек происходит добавление элементов. \par
push в очередь == push в add \par
pop в очередь == если del не пуст, то делаем del.pop(); иначе перекладываем всё из add в del (простым циклом while):
\lstinputlisting[language=C++,
emph={int,char,double,float,unsigned},
emphstyle={\color{blue}}
]{code/7-8_queue_two_stacks.cpp}
front аналогично. Идея основывается на том, что при перебрасывании из add в del инвертируется порядок. Эта структура работает не так долго, так как с одним элементом делают максимум три действия: положить в add, перенести в del, удалить из del $\Rightarrow$ суммарная асимптотика O(n), где n - количество запросов, хотя по отдельности операции работают долго.

\setcounter{section}{7}
\section{Поддержка минимума в очереди.}
Реализуем очередь через два стека. Тогда для стека мы уже умеем поддерживать минимум; в двух стеках add и del лежат все элементы очереди, тогда минимум по очереди - минимум из минимума по add и минимума по del.