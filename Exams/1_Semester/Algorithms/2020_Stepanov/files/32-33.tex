\setcounter{section}{31}
\section{Амортизационный анализ, учётное время работы: определения.}
Пусть S - некая структура данных, которая умеет выполнять q типов запросов $Q_1, \dots, Q_q$ за время ${O}(T_1(n)), \dots, {O}(T_q(n))$. Если $\forall n$ и для любой последовательности запросов к S  ($Q_{i_1}, Q_{i_2}, \dots, Q_{i_n}$) суммарное время их обработки есть: ${O}(\sum_{j=1}^n T_{i_j}(n))$, то ${O}(T_1(n)), \dots, {O}(T_q(n))$ - \textbf{амортизационное (учётное) время обработки всех типов запросов.}

Таким образом, по сути, мы перераспределили время работы отдельных запросов так, чтобы суммарное время обработки не изменялось. \par
\textbf{Пример:} Пусть в реализации функции grow() буфер удваивается. Тогда амортизированная стоимость функции Add составляет O(1). \par
$\blacktriangle$
Рассмотрим последовательность из n операций Add. Обозначим P(k) - время выполнения Add в случае, когда size = k, где size - количество элементов в массиве. Тогда $P(k) \leqslant c_1k$, если k - степень двойки, $P(k) \leqslant c_2$ в противном случае. Но тогда:
\[
S(N) = \sum_{k=0}^{n-1}P(k) \leqslant c_1 \cdot \sum_{m: 2^m < n}2^m + c_2 \cdot \sum_{k: k \neq 2^m}1 \leqslant 2c_1n + c_2n = (2c_1 + c_2)n
\]
Тогда амортизационное время Add() составляет O(1).
$\blacksquare$

\setcounter{section}{32}
\section{Метод монеток (бухгалтерский учёт).}
\textbf{Идея метода:} за каждую операцию мы совершаем некоторую предоплату: мы совершаем много быстрых ("дешёвых") операций, а на сложные операции мы расходуем то время, которое "накопилось" с быстрых операций. \par
\textbf{Строгое описание:} Пусть есть n запросов к структуре S. Во время i-ого запроса мы можем внести в банк $d_i$ монеток. Также можно снять $w_i$ монеток со счёта (deposit, withdrawal), а ещё нужно потратить некоторое время на обработку запроса: $t_i$. $a_i = d_i + t_i - w_i$. \par
\textbf{Утверждение:} Если на счету всегда неотрицательное количество денег, то $a_i$ и есть учётное время обработки операции. \par
$\blacktriangle$
Рассмотрим n запросов к структуре S: $Q_{i_1}, Q_{i_2}, \dots, Q_{i_n}$, каждый обрабатывается за $t_{i_1}, \dots, t_{i_n}$. Тогда осталось проверить, что $t_{i_1} + \dots + t_{i_n} = {O}(a_1 + \dots + a_n)$. Расписываем сумму $a_i$, но это то же самое, что сумма $t_i$ + что-то не отрицательное. 
$\blacksquare$