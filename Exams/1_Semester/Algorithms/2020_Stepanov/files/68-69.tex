\setcounter{section}{67}
\section{Онлайн vs. оффлайн: дерево поиска оффлайн.}
\textbf{Определение:} Когда нам нужно отвечать на запросы задачи делятся на два типа
\begin{enumerate}
    \item \textit{онлайн:} ответить на запрос нужно до прихода следующего
    \item \textit{офлайн:} все запросы известны заранее
\end{enumerate}
\subsection*{Дерево поиска офлайн}
\par Пусть нам пришло $q$ запросов вида find, insert, erase
\begin{enumerate}
    \item Считываем все запросы в массив
    \item Сортируем массив за $O(q \log q)$
    \item Создаем массив длины $q$ из нулей и единиц. Ноль означает, что данное число еще не в дереве, а один - что оно лежит в нем
    \item Отвечаем на запросы. Бинпоиском находим позицию нового числа за $O(\log q) $\begin{enumerate}
        \item find: возвращаем то, что лежит в этой ячейке
        \item insert: записываем в ячейку 1
        \item erase: записываем в ячейку 0
    \end{enumerate}
\end{enumerate}
\par Получаем суммарную асимптотику $O(q \log q)$. Но константа здесь меньше чем в обычном дереве, так как здесь все происходит в массиве.
\setcounter{section}{68}
\section{Онлайн vs. оффлайн: сжатие координат.}
\par Проиллюстрируем метод сжатия координат на примере задачи дерева отрезков в офлайн. Пусть дано $q$ запросов\begin{enumerate}
    \item Поместим все числа из запросов в массив
    \item Отсортируем его. Асимптотика: $O(q \log q)$. Таким образом, мы произвели сжатие координат: координатой каждого числа является его индекс в этом массиве
    \item Построим обычное дерево отрезков на этом массиве
    \item В момент прихода нового запроса будем вычислять его координату (находить его в массиве с помощью бинарного поиска) и подавать в дерево отрезков запрос в виде координат. Асимптотика ответа на запрос: $O(\log q)$
\end{enumerate}
\par Это решение является альтернативой динамического дерева отрезков, если нам не нужно отвечать на запросы в онлайне. Суммарная асимптотика получается $O(q \log q)$