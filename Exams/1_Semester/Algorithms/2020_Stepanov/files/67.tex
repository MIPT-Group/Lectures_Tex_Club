\setcounter{section}{66}
\section{Динамическое дерево отрезков: определение и реализация.}
\par \textbf{Идея:} иногда нам дан большой отрезок, но запрсов не так много. Тогда мы можем не создавать вершины, которые не используются, а создавать только те, которые находятся на пути к элементам, которые мы обновляли.
\par \textbf{Классическая задача:} Дана прямая длинной $n\; (1 \leqslant n \leqslant N), N=10^{18}$, есть запросы двух видов
\begin{enumerate}
    \item Присвоить значение на $[l, r]$
    \item Вывести сумму на $[l,r]$
\end{enumerate}
\subsection*{Простая реализация:}
\lstinputlisting[language=C++,
emph={int,char,double,float,unsigned},
emphstyle={\color{blue}}
]{code/67_dynamic_do.cpp}
\par \textbf{Замечание:} Эта реализация мало отличается от обычного ДО, тут просто добавлен unordered map, чтобы можно было создавать элемент по любому ключу (асимптотика ответа на запрос: $O(\log N)$). Однако unordered map может занимать много памяти, поэтому может быть эффективнее хранить нужные вершины ДО как дерево, но в векторе, и вместо указателей на детей прописывать их индексы в векторе. Тогда на каждом запросе обновления будет добавляться не более $O(\log N)$ памяти, и на любой запрос структура будет отвечать за $O(\log N)$