\section{Вычислимость}

\subsection{Моделирование машины Тьюринга с несколькими лентами на машине Тьюринга с одной лентой.}
\textbf{Машина Тьюринга (МТ) состоит из:} \par
– бесконечной в две стороны ленты, в ячейках которой могут быть записаны символы
алфавита A (некоторого конечного множества);\par
– головки, которая может двигаться вдоль ленты, обозревая в каждый данный момент
времени одну из ячеек;\par
– оперативной памяти, которая имеет конечный размер (другими словами, состояние оперативной памяти — это элемент некоторого конечного множества, которое называется
множеством состояний МТ Q);\par
– таблицы переходов (или программы), которая задаёт функцию.

У \textbf{многоленточных} машин не одна лента, а несколько (фиксированное число для конкретной машины). На каждой ленте есть своя головка. За такт работы головки могут перемещаться по всем лентам. Действие на такте работы зависит как от состояния машины, так и от всего набора символов, которые видят головки машины на всех лентах.\par
Чтобы задать машину с h лентами, нужно указать:\par
– алфавит A, в котором выделен пустой символ $\Lambda$;\par
– множество состояний Q, в котором выделено начальное состояние $q_0$; \par
– таблицу переходов, которая теперь является функцией вида
$\delta : A^h \times Q \rightarrow A^h \times Q \times \{-1, 0, +1\}^h$
(первый аргумент — символы, которые машина видит на ленте; последний — команды
движения для головок на каждой ленте); \par
– выделить среди лент ленту входа и ленту результата (возможно, что это одна и та же
лента).

h-МТ M \textbf{вычисляет} функцию $f : B^* \rightarrow B^*$
(где B — подмножество алфавита машины, не содержащее пустого символа), если для каждого w из области определения функции f результат работы M равен f(w), а для каждого w не из области определения f машина M не останавливается на входе w. \\
\\
\emph{Любая функция, вычислимая на многоленточной МТ, вычислима и на одноленточной машине.} \par
Докажем, построив для произвольной h-МТ искомую одноленточную. Если описывать конфигурации h-МТ $M_h$ в виде матрицы конфигурации размера $h \times N$, то каждый столбец такой матрицы может находиться в конечном числе состояний: не более $(A \cdot (Q + 1))^h$, где A — размер алфавита, а Q — количество состояний.

Моделирующая машина $M_1$ использует расширенный алфавит из $A + (A \cdot (Q + 1))^h$
(пустой символ и символы, отвечающие различным столбцам матрицы конфигурации). Она поддерживает описание матрицы конфигурации машины $M_h$ в этом алфавите и изменяет его, моделируя
работу $M_h$ по тактам.

Поскольку действия $M_h$ на каждом такте работы зависят от её состояния и символов под
головками на каждой ленте, машина $M_1$ поддерживает также и эту информацию, записывая
её в «оперативную память». Т.е. состояния $M_1$ представляются парами («управляющее состояние», «оперативная память»).

Такт работы машины $M_h$ моделируется машиной $M_1$ в два этапа. На первом этапе машина $M_1$ просматривает все непустые ячейки на своей ленте слева направо и определяет, какие символы расположены под текущими положениями головок машины $M_h$.

На втором этапе $M_1$ изменяет содержимое своей ленты в соответствии с таблицей переходов
машины $M_h$. \\
\\

Более детальное описание устройства $M_1$: 

- Алфавит машины $M_1$ — $A' = A \cup (A \times (Q \cup \Lambda))^h$;

- Пустой символ тот же, что и у моделируемой машины $M_h$;

- Машина $M_1$ является последовательным соединением трёх машин: $M_s$, $M_w$, $M_f$.
\\
\\
1. $M_s$. Первая машина $M_s$ подготавливает содержимое ленты к двухэтапному моделированию тактов работы машины $M_h$. Машина $M_s$ просматривает ячейки входного слова. Первый символ $a_1$
она заменяет на$ ((a_1, q_0),(\Lambda, q_0), . . . ,(\Lambda, q_0))$ (это первый столбец матрицы начальной конфигурации $M_h$), а каждый последующий символ входа a на $((a,\Lambda),(\Lambda,\Lambda), . . . ,(\Lambda,\Lambda))$ (это остальные
столбцы матрицы начальной конфигурации — напомним, что в начальной конфигурации все
ленты, кроме входной, пусты). Обнаружив пустой символ $\Lambda$, машина $M_s$ возвращается в крайнее левое положение и останавливается.
\\
\\
2. $M_w$. Вторая машина $M_w$ моделирует такты работы $M_h$ описанным выше способом. Она проходит непустые ячейки ленты два раза. При движении слева направо машина $M_w$ «запоминает»
символы под головками машины $M_h$ по следующему правилу: если в очередном столбце матрицы конфигурации машины $M_h$ на i-й позиции находится пара $(a, q), q \in Q$, то i-я головка
расположена над символом a. К концу первого прохода в оперативной памяти $M_w$ содержится полная информация о символах под головками и состоянии $M_h$, что однозначно определяет строчку таблицы переходов $M_h$, которую нужно применить на данном такте. Если такой строчки нет, то $M_w$ заканчивает работу.

На втором проходе найденная строчка таблицы переходов $M_h$ используется для обновления
матрицы конфигурации. Информация о символах на лентах $M_h$ обновляется по следующему
правилу: если в очередном столбце матрицы конфигурации машины $M_h$ на i-й позиции находится пара $(a, q), q \in Q$, то столбец меняется так, чтобы в этой позиции было написана пара
$(a', q)$, где $a'$ — символ, который $M_h$ записывает на i-ую ленту. Те пары в столбце, которые
соответствуют ячейкам, над которыми нет головки, не изменяются.


Кроме того, нужно обновить информацию о положениях головок соответственно текущей
команде движения. Для этого машина $M_w$ переписывает вторые компоненты пар, из которых
состоит столбец матрицы конфигурации $M_h$ (т.е. текущий столбец матрицы). Движение по
каждой ленте может быть как влево, так и вправо. Поэтому для выполнения этого действия
$M_w$ перемещается из текущего положения на шаг вправо, записывая в этот столбец новые
положения головок, и на шаг влево, выполняя аналогичное действие. При выполнении этих
действий машина $M_w$ может выйти за пределы рабочей зоны (матрицы конфигурации). Тогда
она оказывается над пустым символом, который заменяется на подходящий столбец, описывающий пустые символы и положения головок машины $M_h$.
\\
\\
3. $M_f$. По завершении работы $M_w$ начинает работу третья машина $M_f$ , которая восстанавливает на ленте состояние ленты результата машины $M_h$. Она проходит по всем ячейкам рабочей зоны и
заменяет столбец матрицы конфигурации на символ из алфавита A машины $M_h$, если головка
$M_h$ на ленте результата не находится в этом столбце. Затем она возвращается в ту ячейку,
которая соответствует положению головки на ленте результата машины $M_h$, и производит ту
же замену. После этого $M_f$ останавливается с чувством выполненного долга.