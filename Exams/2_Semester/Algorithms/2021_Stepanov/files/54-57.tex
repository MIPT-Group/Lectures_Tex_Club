\setcounter{section}{53}
\section{Алгоритм Флойда: поиск попарных кратчайших расстояний в графе без отрицательных циклов. Реализация, асимптотика.}
    
    \textit{Применение: } поиск попарных кратчайших расстояний.\\
    
    \textit{Требования к графу: } допускаются отрицательные рёбра, но нет отрицательных циклов.\\
    
    \textit{Описание алгоритма: }\\
    
    Введём трехмерную динамику:\\
    $dp[i][j][k]$ -- минимальная длина пути между $i$ и $j$, такая, что все промежуточные вершины имеют номера не больше, чем $k$.\\
    
    База:\\
    $dp[i][j][0] = $ вес ребра из $i$ в $j$ ($+\infty$, если ребра нет)\\
    
    Переход:\\
    Пусть посчитаны первые $k$ слоёв. Построим $k + 1$ слой.\\
    $dp[i][j][k + 1] = min(dp[i][j][k], dp[i][k + 1][k] + dp[k + 1][j][k])$, то есть либо не берём $k + 1$ вершину, либо берем.\\
    
    Ответ: $dp[i][j][n]$, где $n$ -- количество вершин.\\
    
    \textit{Асимптотика: } $O(n^3)$\\
    \textit{Память: } $O(n^3)$\\
    
    Память можно оптимизировать до $O(n^2)$, если в качестве $dp$ использовать матрицу смежности графа:\\
    
    Пусть $g$ -- матрица смежности графа. Тогда алгоритм Флойда можно написать так:
    
    \begin{lstlisting}
    for (k = 1 ... n) {
        for (i = 1 ... n) {
            for (j = 1 ... n) {
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
            }
        }
    }
    \end{lstlisting}
    
    

\setcounter{section}{54}
\section{Восстановление ответа (пути) в алгоритме Флойда.}

Заведем массив $p[i][j]$, заполним его каким-то нейтральным элементом (например, -1). Если на каком-то шаге выгоднее идти через вершину $k$, то есть $dp[i][j][k + 1] == dp[i][k + 1][k] + dp[k + 1][j][k]$, то сохраняем это: $p[i][j] = k$.\\

Теперь найти путь между $i$ и $j$ можно рекурсивно:\\
Если на какой-то этапе $dp[i][j] == -1$, то кратчайший путь -- ребро между $i$ и $j$.\\
Если $dp[i][j] = k \neq -1$, то путь из $i$ в $j$ -- это путь из $i$ в $k$ и из $k$ в $j$ (их находим рекурсивно).


\setcounter{section}{55}
\section{Алгоритм Форда—Беллмана: поиск кратчайших расстояний от одной вершины до всех. Реализация, асимптотика (в случае отсутствия отрицательных циклов).}

\textit{Применение: } нахождение минимального пути от вершины $s$ до вершины $t$ (в графе могут быть и отрицательные рёбра, и отрицательные циклы).\\

\textit{Описание алгоритма: }\\
    
Введём двумерную динамику:\\
$dp[v][k]$ -- кратчайшее расстояние от $s$ до $v$ при использовании не более, чем $k$ рёбер.\\

База: $dp[v][0] = 
\begin{cases}
    0, v = s\\
    +\infty, v \neq s
\end{cases}
$\\

Переход:\\
Пусть посчитаны первые $k$ слоёв. Тогда $dp[u][k + 1] = \min(dp[u][k], \min\limits_{(v, u)} dp[v][k] + cost(v, u))$, то есть либо оставляем ответ, достижимый за $k$ рёбер, либо перебираем все входящие в $u$ рёбра, и выбираем из них минимальное.\\

Ответ:\\
dp[v][n - 1], если нет отрицательных циклов\\

\textit{Асимптотика: } $O(nm)$, $n$ -- количество слоёв в $dp$, $m$ -- переход между слоями.


\setcounter{section}{56}
\section{Алгоритм Форда—Беллмана: нахождение кратчайших расстояний от одной вершины до всех в случае наличия отрицательных циклов.}

Для обработки отрицательных циклов найдём дополнительно $n$-ый слой $dp[v][n]$.

\begin{proposition}
    Пусть $C$ -- отрицательный цикл, достижимый из $s$. Тогда $\exists v \in C: dp[v][n] < dp[v][n - 1]$.
    
    \begin{proof}
        Пусть $c_1, ..., c_k$ -- веса рёбер в цикле $C$. Предположим противное: $\forall v \in C dp[v][n] = dp[v][n - 1]$ (больше оно быть не может по переходу динамики).\\
        Пусть $c_i$ -- вес ребра, соединяющего вершины $v_i$ и $v_{i + 1}$. Тогда $dp[v_{i + 1}][n] \leq dp[v_i][n - 1] + c_i$.\\
        Сложим эти неравенства по всем $i$.\\
        $$
            \sum\limits_{v_i \in C} dp[v_i][n] \leq \sum\limits_{v_i \in C} do[v_i][n - 1] + \sum\limits_{i} c_i
        $$
        Первая и вторая суммы равны по предположению, третья сумма меньше нуля (так как цикл отрицательный). Получается, что 0 меньше или равен чего-то отрицательного. Противоречие.
    \end{proof}
    
\end{proposition}

Тогда за $O(nm)$ можем найти хотя бы по одной вершине на каждом отрицательном цикле.\\

$$
dist(s, x) = 
\begin{cases}
    -\infty, \text{если $x$ достижим из одной из вершин отрицательного цикла}\\
    dp[x][n - 1], \text{иначе}
\end{cases}
$$\\

На практике лучше запустить DFS из всех вершин, у которых $dp[v][n] < dp[v][n - 1]$, и пометить все достижимые из них вершины $dist = -\infty$.