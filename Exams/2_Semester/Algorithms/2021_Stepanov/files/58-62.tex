\setcounter{section}{57}
\section{Остовный подграф, остовное дерево. Минимальный остов. Лемма о безопасном ребре.
}

\textbf{Определение.} $T \subset G$~--- \textbf{остовное дерево}, если $T$ содержит все вершины $G$ и является деревом

\textbf{Определение.} Остовный подграф — подграф, содержащий все вершины.

\textbf{Определение.} Минимальным остовным деревом во взвешенном неориентированном графе называется остовное дерево минимального веса.

\textbf{Определение.} Ребро $ ( u, v ) \notin G' $ называется безопасным, если при добавлении его в $ G' $, $ G' \cup \{ ( u, v ) \}$ также является подграфом некоторого минимального остовного дерева графа $ G $.

\textbf{Определение.} $(S,T)$~--- разрез, если $S \cup T = V, S \cap T = \varnothing$

\textbf{Определение.} $(u,v)$ пересекает разрез $(S,T)$, если $u$ и $v$~--- в разных частях разреза. 

\begin{theorem}[О безопасном ребре]
Рассмотрим связный неориентированный взвешенный граф $ G = ( V, E ) $ с весовой функцией $w : E \to \mathbb{R}$. Пусть $ G' = ( V, E' ) $ --- подграф некоторого минимального остовного дерева $ G $, $ \langle S, T \rangle $ --- разрез $ G $, такой, что ни одно ребро из $ E' $ не пересекает разрез, а $ ( u, v ) $ --- ребро минимального веса среди всех ребер, пересекающих разрез $ \langle S, T \rangle $. Тогда ребро $ e = ( u, v ) $ является безопасным для $ G'$.
\end{theorem}

\begin{proof}
Достроим $ E' $ до некоторого минимального остовного дерева, обозначим его $T_{min}$. Если ребро $e \in T_{min}$, то лемма доказана, поэтому рассмотрим случай, когда ребро $e \notin T_{min}$. Рассмотрим путь в $T_{min}$ от вершины $u$ до вершины $v$. Так как эти вершины принадлежат разным долям разреза, то хотя бы одно ребро пути пересекает разрез, назовем его $e'$. По условию леммы $w(e) \leqslant w(e')$. Заменим ребро $e'$ в $T_{min}$ на ребро $e$. Полученное дерево также является минимальным остовным деревом графа $G$, поскольку все вершины $G$ по-прежнему связаны и вес дерева не увеличился. Следовательно $E' \cup \{e\} $ можно дополнить до минимального остовного дерева в графе $G$, то есть ребро $e$ --- безопасное. 
\end{proof}

\setcounter{section}{58}
\section{Алгоритм Прима: доказательство корректности и реализации за $O(n^2), O(m$ $log$ $n), O(m + n$ $log$ $n)$.}

Алгоритм Прима – алгоритм поиска минимального остовного дерева. 

Идея: пока можем, добавляем к имеющемуся подграфу ($C$) минимального остовного дерева самое легкое ребро из всех, пересекающих разрез (соединяющих наш подграф с оставшейся частью графа).\\

В таком виде асимптотика алгоритма $O(nm)$, однако, ее несложно улучшить до $O(n^2)$. А именно для каждой вершины будем хранить минимальное ребро, которое соединяет ее с вершиной из $C$.

Тогда шагов будет $n - 1$ (в дереве $n - 1$ ребро), на каждом шаге $O(n)$ действий по поиску следующего ребра. Обновление происходит так: для текущей добавленной вершины достаточно обновить минимум по всем ее соседям, не входящим в $C$. Так что асимптотика будет $O(n^2 + m) = O(n^2)$

Заметим, что есть сходство с алгоритмом Дейкстры. Нам нужно делать extract min, а потом decrease key, причем, O(n) раз. Так что мы можем, используя, например, кучу, добиться лучшей асимптотики.

\begin{itemize}
    \item Выбираем произвольную стартовую вершину – начало строящегося дерева. Строим кучу с вершинами, до которых есть ребро из стартовой.
    \item Итеративно добавляем к дереву вершину из кучи  с минимальным по весу ребром до дерева. Саму вершину удаляем из кучи. Добавляем новые вершины, доступные из добавленной вершины по ребрам графа, в кучу. А еще обновляем расстояние до вершины из куче  \Big(удаляем пару (старое расстояние; номер вершины), добавляем пару (новое расстояние; номер вершины)\Big), если от добавленной вершины к ней ведет более легкое ребро.
\end{itemize}

\begin{theorem}
Алгоритм Прима работает за $O(m$ $log$ $n)$ с очередью на куче и за $O(n$ $log$ $n + m)$ при очереди на Фибонначиевой куче.
\end{theorem}

\begin{proof}
~~\parbox[t]{0.95\linewidth}{
    \begin{itemize}
        \item Извлечение вершины из кучи – $O(log$ $n)$
        \item Вставка в кучу $O(log$ $n)$
    \end{itemize}
    
    Пункт 1) выполнится $n$ раз, пункт 2) $m$ раз. 
}
\end{proof}

\setcounter{section}{59}
\section{Система непересекающихся множеств (СНМ). Виды запросов. Эвристика по рангу, эвристика
сжатия путей. Асимптотика ответа на запрос при использовании обеих эвристик (б/д).}

\textbf{Определение.} DSU (СНМ) --- система непересекающихся множеств 
\begin{itemize}
    \item Create(u)~--- создать множество с одним элементом u.
    \item Find(u)~--- найти множество по элементу u, чтобы можно было сравнить их (Find(u) == Find(v)). Для удобства возвращает конкретного представителя множества как своеобразный идентификатор.
    \item Union(u, v) --- объединить два множества, одно из которых содержит элемент u, а другое --- элемент v.
\end{itemize}

Удобно воспринимать множества как подвешенные деревья. Корень -- представитель или, другими словами, лидер. Соответственно, поиск представителя осуществляется как подъем по дереву к корню. Поэтому чем короче путь, тем лучше. Массив $parent$ хранит родителей вершин в наших графах. Значения $parent$ для представителей равно $-1$.

\textbf{Определение.} В операции Union будем присоединять дерево с меньшим рангом к дереву с большим рангом. Это называется ранговая эвристика. Есть два варианта ранговой эвристики: в одном варианте рангом дерева называется количество вершин в нём, в другом — глубина дерева (точнее, верхняя граница на глубину дерева, поскольку при совместном применении эвристики сжатия путей реальная глубина дерева может уменьшаться).

\textbf{Определение.} Эвристика сжатия пути заключается в следующем: когда после вызова {\rm Find}(v) мы найдём искомого лидера p множества, то запомним, что у вершины v и всех пройденных по пути вершин --- именно этот лидер p. Проще всего это сделать, перенаправив их {\rm parent}[] на эту вершину p.

Совместное использование эвристик дает асимптотику $O(\alpha(n))$, где $\alpha(n)$ -- обратная функция Аккермана, которая растёт очень медленно, настолько медленно, что для всех разумных ограничений $n$ она не превосходит 4 (по крайней мере, для $n \leq 10^{600}$ точно).

\setcounter{section}{60}
\section{Асимптотика ответа на запрос в СНМ при использовании только эвристики по рангу.}

\begin{theorem}
Ранговая эвристика дает $O(\log n))$ на каждый запрос.
\end{theorem} 

\begin{proof}
    Рассмотрим ранговую эвристику по глубине дерева. Покажем, что если ранг дерева равен k, то это дерево содержит как минимум $2^k$ вершин (отсюда будет автоматически следовать, что ранг, а, значит, и глубина дерева, есть величина $O(\log n)$). Доказывать будем по индукции: для $k=0$ это очевидно. Ранг дерева увеличивается с $k-1$ до $k$, когда к нему присоединяется дерево ранга $k-1$; применяя к этим двум деревьям размера $k-1$ предположение индукции, получаем, что новое дерево ранга $k$ действительно будет иметь как минимум $2^k$ вершин. 
\end{proof}

\setcounter{section}{61}
\section{Алгоритм Крускала: корректность, реализация, асимптотика.}

Алгоритм Крускала – еще один алгоритм поиска минимального остовного дерева.

\begin{itemize}
    \item Сортируем все ребра графа по весу.
    \item Инициализируем лес деревьев. Изначально каждая вершина --- дерево.
    \item Последовательно рассматриваем ребра графа в порядке возрастания веса. Если очередное ребро соединяет два разных дерева из леса, то объединяем эти два дерева этим ребром в одно дерево. Если очередное ребро соединяет две вершины одного дерева из леса, то пропускаем такое ребро.
    \item Повторяем 3), пока в лесу не останется одно дерево.
\end{itemize}

\begin{theorem}
Алгоритм Крускала корректен
\end{theorem}

\begin{proof}
Рассмотрим шаг алгоритма. Пусть текущее ребро при добавлении не создает цикл. Тогда оно соединяет два разных поддерева в MST, то есть соединяет разрез. У него минимальный вес, значит оно безопасно.
\end{proof}

\begin{theorem}
Алгоритм Крускала работает за $O(m \log m)$
\end{theorem}

\begin{proof}
Сортировка ребер займет $O(m \log m)$.
Работа с СНМ займет $O(m \alpha(n))$, где $\alpha$ — обратная функция Аккермана, которая не превосходит 4 во всех практических приложениях и которую можно принять за константу.
Алгоритм работает за $O(m(\log m +\alpha(n)))= O(m \log m)$. 
\end{proof}

\lstinputlisting[language=C++,
emph={int,char,double,float,unsigned},
emphstyle={\color{blue}}
]{code/62_kruskal.cpp}
    