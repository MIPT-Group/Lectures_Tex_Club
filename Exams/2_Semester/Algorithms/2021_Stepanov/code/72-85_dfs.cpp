int dfs(int v, int flow) {
    if (v == t) return flow; // если уже дошли до стока - возвращаем ответ
    while (ptr[v] != g[v].size()) { // пока есть интересные ребра
        Edge e = g[ptr[v]]; // ptr[v]-ое ребро из v
        if (level[v] + 1 != level[e.to]) { // если это не ребро между слоями
            ++ptr[v]; // отмечаем ребро неинтересным
            continue; // переходим к следующей итерации
        }
        if (e.capacity == e.flow) { // если ребро уже насыщено
            ++ptr[v]; // отмечаем ребро неинтересным
            continue; // перейти к следующей итерации
        }
        int x = dfs(e.to, min(flow, e.capacity - e.flow)); // рекурсивно запускаемся от конца интересного ребра
        if (x > 0) { // если мы смогли протолкнуть ненулевой поток
            e.flow += x; // добавляем поток по e
            reverse_e.flow -= x; // отнимаем поток из обратного ребра
            return x; // возвращаем поток который смогли протолкнуть
        }
        ++ptr[v]; // иначе ребро неинтересно и переходим к следующему
    }
    return 0; // если ничего не получилось вернуть 0
}
